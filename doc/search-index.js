var searchIndex = {};
searchIndex['iron'] = {"items":[[0,"","iron","The main crate for the Iron library."],[1,"Request","","The `Request` given to all `Middleware`."],[11,"url","","The requested URL.",0],[11,"remote_addr","","The originating address of the request.",0],[11,"headers","","The request headers.",0],[11,"body","","The request body.",0],[11,"method","","The request method.",0],[11,"extensions","","Extensible storage for data passed between middleware.",0],[1,"Url","","HTTP/HTTPS URL type for Iron."],[11,"scheme","","The lower-cased scheme of the URL, typically \"http\" or \"https\".",1],[11,"host","","The host field of the URL, probably a domain.",1],[11,"port","","The connection port.",1],[11,"path","","The URL path, the resource to be accessed.",1],[11,"username","","The URL username field, from the userinfo section of the URL.",1],[11,"password","","The URL password field, from the userinfo section of the URL.",1],[11,"query","","The URL query string.",1],[11,"fragment","","The URL fragment.",1],[1,"Response","","The response representation given to `Middleware`"],[11,"body","","The body of the response.",2],[11,"headers","","The headers of the response.",2],[11,"status","","The response status-code.",2],[11,"extensions","","A TypeMap to be used as an extensible storage for data\nassociated with this Response.",2],[1,"ChainBuilder","","The default Chain used in Iron."],[1,"Iron","","The primary entrance point to `Iron`, a `struct` to instantiate a new server."],[11,"handler","","Iron contains a `Handler`, which it uses to create responses for client\nrequests.",3],[0,"typemap","","typemap crate re-exports"],[10,"new","typemap","Create a new, empty TypeMap.",4],[10,"insert","","Insert a value into the map with a specified key type.",4],[10,"find","","Find a value in the map and get a reference to it.",4],[10,"find_mut","","Find a value in the map and get a mutable reference to it.",4],[10,"contains","","Check if a key has an associated value stored in the map.",4],[10,"remove","","Remove a value from the map.",4],[10,"data","","Read the underlying HashMap",4],[10,"data_mut","","Get a mutable reference to the underlying HashMap",4],[10,"len","","",4],[10,"is_empty","","",4],[10,"clear","","",4],[1,"TypeMap","iron::typemap","A map keyed by types."],[6,"Assoc","","This trait defines the relationship between keys and values in a TypeMap."],[10,"clone","iron","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"parse","","Create a URL from a string.",1],[10,"from_generic_url","","Create a `Url` from a `rust-url` `Url`.",1],[10,"fmt","","",1],[10,"encode","","",1],[10,"decode","","",1],[10,"fmt","","",0],[10,"from_http","","Create a request from an HttpRequest.",0],[10,"extensions","","",0],[10,"extensions_mut","","",0],[10,"load","http::server::request","Get a response from an open socket.",5],[10,"new","http::buffer","",6],[10,"poke_byte","","Poke a single byte back so it will be read next. For this to make sense, you must have just\nread that byte. If `self.pos` is 0 and `self.max` is not 0 (i.e. if the buffer is just\nfilled\nVery great caution must be used in calling this as it will fail if `self.pos` is 0.",6],[10,"read_byte","","Slightly faster implementation of read_byte than that which is provided by ReaderUtil\n(which just uses `read()`)",6],[10,"finish_response","","Finish off writing a response: this flushes the writer and in case of chunked\nTransfer-Encoding writes the ending zero-length chunk to indicate completion.",6],[10,"read","","Read at most N bytes into `buf`, where N is the minimum of `buf.len()` and the buffer size.",6],[10,"read_at_least","","",6],[10,"read_byte","","",6],[10,"push","","",6],[10,"push_at_least","","",6],[10,"read_exact","","",6],[10,"read_to_end","","",6],[10,"read_to_string","","",6],[10,"bytes","","",6],[10,"read_le_uint_n","","",6],[10,"read_le_int_n","","",6],[10,"read_be_uint_n","","",6],[10,"read_be_int_n","","",6],[10,"read_le_uint","","",6],[10,"read_le_int","","",6],[10,"read_be_uint","","",6],[10,"read_be_int","","",6],[10,"read_be_u64","","",6],[10,"read_be_u32","","",6],[10,"read_be_u16","","",6],[10,"read_be_i64","","",6],[10,"read_be_i32","","",6],[10,"read_be_i16","","",6],[10,"read_be_f64","","",6],[10,"read_be_f32","","",6],[10,"read_le_u64","","",6],[10,"read_le_u32","","",6],[10,"read_le_u16","","",6],[10,"read_le_i64","","",6],[10,"read_le_i32","","",6],[10,"read_le_i16","","",6],[10,"read_le_f64","","",6],[10,"read_le_f32","","",6],[10,"read_u8","","",6],[10,"read_i8","","",6],[10,"by_ref","","",6],[10,"write","","",6],[10,"flush","","",6],[10,"flush","","",6],[10,"write_fmt","","",6],[10,"write_str","","",6],[10,"write_line","","",6],[10,"write_char","","",6],[10,"write_int","","",6],[10,"write_uint","","",6],[10,"write_le_uint","","",6],[10,"write_le_int","","",6],[10,"write_be_uint","","",6],[10,"write_be_int","","",6],[10,"write_be_u64","","",6],[10,"write_be_u32","","",6],[10,"write_be_u16","","",6],[10,"write_be_i64","","",6],[10,"write_be_i32","","",6],[10,"write_be_i16","","",6],[10,"write_be_f64","","",6],[10,"write_be_f32","","",6],[10,"write_le_u64","","",6],[10,"write_le_u32","","",6],[10,"write_le_u16","","",6],[10,"write_le_i64","","",6],[10,"write_le_i32","","",6],[10,"write_le_i16","","",6],[10,"write_le_f64","","",6],[10,"write_le_f32","","",6],[10,"write_u8","","",6],[10,"write_i8","","",6],[10,"by_ref","","",6],[10,"new","http::client::request","Create a `RequestWriter` writing to the specified location",7],[10,"new_request","","",7],[10,"try_connect","","Connect to the remote host if not already connected.",7],[10,"connect","","Connect to the remote host; fails if already connected.\nReturns ``true`` upon success and ``false`` upon failure (also use conditions).",7],[10,"try_write_headers","","Write the Request-Line and headers of the response, if we have not already done so.",7],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",7],[10,"read_response","","Send the request and construct a `ResponseReader` out of it.",7],[10,"write","","",7],[10,"flush","","",7],[10,"flush","","",7],[10,"write_fmt","","",7],[10,"write_str","","",7],[10,"write_line","","",7],[10,"write_char","","",7],[10,"write_int","","",7],[10,"write_uint","","",7],[10,"write_le_uint","","",7],[10,"write_le_int","","",7],[10,"write_be_uint","","",7],[10,"write_be_int","","",7],[10,"write_be_u64","","",7],[10,"write_be_u32","","",7],[10,"write_be_u16","","",7],[10,"write_be_i64","","",7],[10,"write_be_i32","","",7],[10,"write_be_i16","","",7],[10,"write_be_f64","","",7],[10,"write_be_f32","","",7],[10,"write_le_u64","","",7],[10,"write_le_u32","","",7],[10,"write_le_u16","","",7],[10,"write_le_i64","","",7],[10,"write_le_i32","","",7],[10,"write_le_i16","","",7],[10,"write_le_f64","","",7],[10,"write_le_f32","","",7],[10,"write_u8","","",7],[10,"write_i8","","",7],[10,"by_ref","","",7],[10,"construct","http::client::response","",8],[10,"read","","",8],[10,"read_at_least","","",8],[10,"read_byte","","",8],[10,"push","","",8],[10,"push_at_least","","",8],[10,"read_exact","","",8],[10,"read_to_end","","",8],[10,"read_to_string","","",8],[10,"bytes","","",8],[10,"read_le_uint_n","","",8],[10,"read_le_int_n","","",8],[10,"read_be_uint_n","","",8],[10,"read_be_int_n","","",8],[10,"read_le_uint","","",8],[10,"read_le_int","","",8],[10,"read_be_uint","","",8],[10,"read_be_int","","",8],[10,"read_be_u64","","",8],[10,"read_be_u32","","",8],[10,"read_be_u16","","",8],[10,"read_be_i64","","",8],[10,"read_be_i32","","",8],[10,"read_be_i16","","",8],[10,"read_be_f64","","",8],[10,"read_be_f32","","",8],[10,"read_le_u64","","",8],[10,"read_le_u32","","",8],[10,"read_le_u16","","",8],[10,"read_le_i64","","",8],[10,"read_le_i32","","",8],[10,"read_le_i16","","",8],[10,"read_le_f64","","",8],[10,"read_le_f32","","",8],[10,"read_u8","","",8],[10,"read_i8","","",8],[10,"by_ref","","",8],[10,"connect","http::client::sslclients::openssl","",9],[10,"read","","",9],[10,"read_at_least","","",9],[10,"read_byte","","",9],[10,"push","","",9],[10,"push_at_least","","",9],[10,"read_exact","","",9],[10,"read_to_end","","",9],[10,"read_to_string","","",9],[10,"bytes","","",9],[10,"read_le_uint_n","","",9],[10,"read_le_int_n","","",9],[10,"read_be_uint_n","","",9],[10,"read_be_int_n","","",9],[10,"read_le_uint","","",9],[10,"read_le_int","","",9],[10,"read_be_uint","","",9],[10,"read_be_int","","",9],[10,"read_be_u64","","",9],[10,"read_be_u32","","",9],[10,"read_be_u16","","",9],[10,"read_be_i64","","",9],[10,"read_be_i32","","",9],[10,"read_be_i16","","",9],[10,"read_be_f64","","",9],[10,"read_be_f32","","",9],[10,"read_le_u64","","",9],[10,"read_le_u32","","",9],[10,"read_le_u16","","",9],[10,"read_le_i64","","",9],[10,"read_le_i32","","",9],[10,"read_le_i16","","",9],[10,"read_le_f64","","",9],[10,"read_le_f32","","",9],[10,"read_u8","","",9],[10,"read_i8","","",9],[10,"by_ref","","",9],[10,"write","","",9],[10,"flush","","",9],[10,"flush","","",9],[10,"write_fmt","","",9],[10,"write_str","","",9],[10,"write_line","","",9],[10,"write_char","","",9],[10,"write_int","","",9],[10,"write_uint","","",9],[10,"write_le_uint","","",9],[10,"write_le_int","","",9],[10,"write_be_uint","","",9],[10,"write_be_int","","",9],[10,"write_be_u64","","",9],[10,"write_be_u32","","",9],[10,"write_be_u16","","",9],[10,"write_be_i64","","",9],[10,"write_be_i32","","",9],[10,"write_be_i16","","",9],[10,"write_be_f64","","",9],[10,"write_be_f32","","",9],[10,"write_le_u64","","",9],[10,"write_le_u32","","",9],[10,"write_le_u16","","",9],[10,"write_le_i64","","",9],[10,"write_le_i32","","",9],[10,"write_le_i16","","",9],[10,"write_le_f64","","",9],[10,"write_le_f32","","",9],[10,"write_u8","","",9],[10,"write_i8","","",9],[10,"by_ref","","",9],[10,"new","http::server::request","",10],[10,"read_request_line","","",10],[10,"read_header","","Read a header (name, value) pair.",10],[10,"read","","",10],[10,"read_at_least","","",10],[10,"read_byte","","",10],[10,"push","","",10],[10,"push_at_least","","",10],[10,"read_exact","","",10],[10,"read_to_end","","",10],[10,"read_to_string","","",10],[10,"bytes","","",10],[10,"read_le_uint_n","","",10],[10,"read_le_int_n","","",10],[10,"read_be_uint_n","","",10],[10,"read_be_int_n","","",10],[10,"read_le_uint","","",10],[10,"read_le_int","","",10],[10,"read_be_uint","","",10],[10,"read_be_int","","",10],[10,"read_be_u64","","",10],[10,"read_be_u32","","",10],[10,"read_be_u16","","",10],[10,"read_be_i64","","",10],[10,"read_be_i32","","",10],[10,"read_be_i16","","",10],[10,"read_be_f64","","",10],[10,"read_be_f32","","",10],[10,"read_le_u64","","",10],[10,"read_le_u32","","",10],[10,"read_le_u16","","",10],[10,"read_le_i64","","",10],[10,"read_le_i32","","",10],[10,"read_le_i16","","",10],[10,"read_le_f64","","",10],[10,"read_le_f32","","",10],[10,"read_u8","","",10],[10,"read_i8","","",10],[10,"by_ref","","",10],[10,"assert_receiver_is_total_eq","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"ne","","",11],[10,"fmt","","",11],[10,"new","http::server::response","Create a `ResponseWriter` writing to the specified location",12],[10,"write_content_auto","","Write a response with the specified Content-Type and content; the Content-Length header is\nset based upon the contents",12],[10,"try_write_headers","","Write the Status-Line and headers of the response, if we have not already done so.",12],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",12],[10,"finish_response","","",12],[10,"write","","",12],[10,"flush","","",12],[10,"flush","","",12],[10,"write_fmt","","",12],[10,"write_str","","",12],[10,"write_line","","",12],[10,"write_char","","",12],[10,"write_int","","",12],[10,"write_uint","","",12],[10,"write_le_uint","","",12],[10,"write_le_int","","",12],[10,"write_be_uint","","",12],[10,"write_be_int","","",12],[10,"write_be_u64","","",12],[10,"write_be_u32","","",12],[10,"write_be_u16","","",12],[10,"write_be_i64","","",12],[10,"write_be_i32","","",12],[10,"write_be_i16","","",12],[10,"write_be_f64","","",12],[10,"write_be_f32","","",12],[10,"write_le_u64","","",12],[10,"write_le_u32","","",12],[10,"write_le_u16","","",12],[10,"write_le_i64","","",12],[10,"write_le_i32","","",12],[10,"write_le_i16","","",12],[10,"write_le_f64","","",12],[10,"write_le_f32","","",12],[10,"write_u8","","",12],[10,"write_i8","","",12],[10,"by_ref","","",12],[10,"hash","http::method","",13],[10,"clone","","",13],[10,"clone_from","","",13],[10,"assert_receiver_is_total_eq","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"ne","","",13],[10,"from_str","","Get a *known* `Method` from an *ASCII* string, regardless of case.",13],[10,"fmt","","",13],[10,"from_str_or_new","","Get a `Method` from an *ASCII* string.",13],[10,"assert_receiver_is_total_eq","http::headers::accept_ranges","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"ne","","",14],[10,"clone","","",14],[10,"clone_from","","",14],[10,"assert_receiver_is_total_eq","","",15],[10,"eq","","",15],[10,"ne","","",15],[10,"ne","","",15],[10,"clone","","",15],[10,"clone_from","","",15],[10,"from_stream","","",15],[10,"to_stream","","",15],[10,"http_value","","",15],[10,"to_stream","","",15],[10,"assert_receiver_is_total_eq","http::headers::connection","",16],[10,"eq","","",16],[10,"ne","","",16],[10,"ne","","",16],[10,"clone","","",16],[10,"clone_from","","",16],[10,"fmt","","",16],[10,"from_stream","","",16],[10,"to_stream","","",16],[10,"http_value","","",16],[10,"to_stream","","",16],[10,"assert_receiver_is_total_eq","http::headers::content_type","",17],[10,"eq","","",17],[10,"ne","","",17],[10,"ne","","",17],[10,"clone","","",17],[10,"clone_from","","",17],[10,"new","","",17],[10,"fmt","","",17],[10,"from_stream","","",17],[10,"to_stream","","",17],[10,"http_value","","",17],[10,"to_stream","","",17],[10,"assert_receiver_is_total_eq","http::headers::etag","",18],[10,"eq","","",18],[10,"ne","","",18],[10,"ne","","",18],[10,"clone","","",18],[10,"clone_from","","",18],[10,"fmt","","",18],[10,"from_stream","","",18],[10,"to_stream","","",18],[10,"http_value","","",18],[10,"to_stream","","",18],[10,"assert_receiver_is_total_eq","http::headers::host","",19],[10,"eq","","",19],[10,"ne","","",19],[10,"ne","","",19],[10,"clone","","",19],[10,"clone_from","","",19],[10,"fmt","","",19],[10,"from_stream","","",19],[10,"http_value","","",19],[10,"to_stream","","",19],[10,"assert_receiver_is_total_eq","http::headers::transfer_encoding","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"ne","","",20],[10,"clone","","",20],[10,"clone_from","","",20],[10,"from_stream","","",20],[10,"to_stream","","",20],[10,"http_value","","",20],[10,"to_stream","","",20],[10,"assert_receiver_is_total_eq","http::headers","",21],[10,"eq","","",21],[10,"ne","","",21],[10,"ne","","",21],[10,"clone","","",21],[10,"clone_from","","",21],[10,"assert_receiver_is_total_eq","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"ne","","",22],[10,"new","","",23],[10,"verify_consumed","","Check that the entire header value has been consumed.",23],[10,"some_if_consumed","","Turn a constructed header value into an Option: Some(value) if the header value is consumed\nor None if it is not, thus indicating: \"I'm finished and expect nothing more. Anything more\nis an error.\"",23],[10,"consume_optional_lws","","Consume optional `*LWS`. That is, zero or more of SP and HT, until it\ngets to something other than SP and HT or gets to the end of the header.",23],[10,"consume_lws","","Consume `1*LWS`. That is, one or more of SP and HT, until it gets to\nsomething other than SP and HT or gets to the end of the header.",23],[10,"consume_comma_lws","","Return values:\n- CommaConsumed if there was a comma and it was consumed;\n- EndOfValue if the header value has been completely consumed;\n- ErrCommaNotFound if the next thing wasn't a comma (this is an error state)",23],[10,"read_quoted_string","","Read a quoted-string from the current position.\nIf the quoted-string is not begun immediately or the header ends before it is completed,\nthen None is returned; TODO: decide if I can return the bytes read (at present, escapes and\ndouble quote would be lost if I did that).",23],[10,"read_token_or_quoted_string","","Read a token (RFC 2616 definition) from the header value.",23],[10,"read_token","","Read a token (RFC 2616 definition) from the header value.",23],[10,"next","","",23],[10,"size_hint","","",23],[10,"chain","","",23],[10,"zip","","",23],[10,"map","","",23],[10,"filter","","",23],[10,"filter_map","","",23],[10,"enumerate","","",23],[10,"peekable","","",23],[10,"skip_while","","",23],[10,"take_while","","",23],[10,"skip","","",23],[10,"take","","",23],[10,"scan","","",23],[10,"flat_map","","",23],[10,"fuse","","",23],[10,"inspect","","",23],[10,"by_ref","","",23],[10,"advance","","",23],[10,"collect","","",23],[10,"nth","","",23],[10,"last","","",23],[10,"fold","","",23],[10,"count","","",23],[10,"all","","",23],[10,"any","","",23],[10,"find","","",23],[10,"position","","",23],[10,"max_by","","",23],[10,"min_by","","",23],[10,"from_stream","collections::vec","",24],[10,"to_stream","","",24],[10,"http_value","","",24],[10,"to_stream","","",24],[10,"from_stream","collections::string","",25],[10,"to_stream","","",25],[10,"http_value","","",25],[10,"to_stream","","",25],[10,"from_stream","url","",26],[10,"http_value","","",26],[10,"to_stream","","",26],[10,"from_stream","http::method","",13],[10,"http_value","","",13],[10,"to_stream","","",13],[10,"from_stream","time","",27],[10,"http_value","","",27],[10,"to_stream","","",27],[10,"clone","http::headers::request","",28],[10,"clone_from","","",28],[10,"new","","",28],[10,"insert","","Consume a header, putting it into this structure.",28],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",28],[10,"iter","","",28],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",28],[10,"next","","",29],[10,"size_hint","","",29],[10,"chain","","",29],[10,"zip","","",29],[10,"map","","",29],[10,"filter","","",29],[10,"filter_map","","",29],[10,"enumerate","","",29],[10,"peekable","","",29],[10,"skip_while","","",29],[10,"take_while","","",29],[10,"skip","","",29],[10,"take","","",29],[10,"scan","","",29],[10,"flat_map","","",29],[10,"fuse","","",29],[10,"inspect","","",29],[10,"by_ref","","",29],[10,"advance","","",29],[10,"collect","","",29],[10,"nth","","",29],[10,"last","","",29],[10,"fold","","",29],[10,"count","","",29],[10,"all","","",29],[10,"any","","",29],[10,"find","","",29],[10,"position","","",29],[10,"max_by","","",29],[10,"min_by","","",29],[10,"header_name","","",30],[10,"header_value","","",30],[10,"write_header","","",30],[10,"value_from_stream","","",30],[10,"clone","http::headers::response","",31],[10,"clone_from","","",31],[10,"new","","",31],[10,"insert","","Consume a header, putting it into this structure.",31],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",31],[10,"iter","","",31],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",31],[10,"next","","",32],[10,"size_hint","","",32],[10,"chain","","",32],[10,"zip","","",32],[10,"map","","",32],[10,"filter","","",32],[10,"filter_map","","",32],[10,"enumerate","","",32],[10,"peekable","","",32],[10,"skip_while","","",32],[10,"take_while","","",32],[10,"skip","","",32],[10,"take","","",32],[10,"scan","","",32],[10,"flat_map","","",32],[10,"fuse","","",32],[10,"inspect","","",32],[10,"by_ref","","",32],[10,"advance","","",32],[10,"collect","","",32],[10,"nth","","",32],[10,"last","","",32],[10,"fold","","",32],[10,"count","","",32],[10,"all","","",32],[10,"any","","",32],[10,"find","","",32],[10,"position","","",32],[10,"max_by","","",32],[10,"min_by","","",32],[10,"header_name","","",33],[10,"header_value","","",33],[10,"write_header","","",33],[10,"value_from_stream","","",33],[10,"fmt","http::rfc2616::content_coding","",34],[10,"from_str","","",34],[10,"fmt","http::rfc2616::transfer_coding","",35],[10,"clone","http::status","",36],[10,"clone_from","","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"ne","","",36],[10,"assert_receiver_is_total_eq","","",36],[10,"code","","Get the status code",36],[10,"reason","","Get the reason phrase",36],[10,"from_code_and_reason","","Get a status from the code and reason",36],[10,"fmt","","",36],[10,"fmt","","",36],[10,"to_i64","","Equivalent to `Some(self.code() as i64)`",36],[10,"to_u64","","Equivalent to `Some(self.code() as u64)`",36],[10,"to_int","","",36],[10,"to_i8","","",36],[10,"to_i16","","",36],[10,"to_i32","","",36],[10,"to_uint","","",36],[10,"to_u8","","",36],[10,"to_u16","","",36],[10,"to_u32","","",36],[10,"to_f32","","",36],[10,"to_f64","","",36],[10,"from_i64","","Get a *registered* status code from the number of its status code.",36],[10,"from_u64","","Get a *registered* status code from the number of its status code.",36],[10,"from_int","","",36],[10,"from_i8","","",36],[10,"from_i16","","",36],[10,"from_i32","","",36],[10,"from_uint","","",36],[10,"from_u8","","",36],[10,"from_u16","","",36],[10,"from_u32","","",36],[10,"from_f32","","",36],[10,"from_f64","","",36],[10,"new","iron","Construct a blank Response",2],[10,"status","","Create a new response with the status.",2],[10,"with","","Create a new response with the specified body and status.",2],[10,"from_file","","Create a response from a file on disk.",2],[10,"fmt","","",2],[10,"extensions","","",2],[10,"extensions_mut","","",2],[10,"listen","","Kick off the server process.",3],[10,"new","","Instantiate a new instance of `Iron`.",3],[10,"new","","Construct a new ChainBuilder from a `Handler`.",37],[10,"new","","",37],[10,"link","","",37],[10,"link_before","","",37],[10,"link_after","","",37],[10,"around","","",37],[10,"call","","",37],[10,"catch","","",37],[10,"call","alloc::boxed","",38],[10,"catch","","",38],[10,"call","alloc::arc","",39],[10,"catch","","",39],[4,"IronError","iron",""],[4,"IronResult","",""],[6,"BeforeMiddleware","","`BeforeMiddleware` are fired before a `Handler` is called inside of a Chain."],[9,"before","","Do whatever work this middleware should do with a `Request` object.",40],[10,"catch","","Try to `catch` an error thrown by this Middleware or a previous `BeforeMiddleware`.",40],[6,"AfterMiddleware","","`AfterMiddleware` are fired after a `Handler` is called inside of a Chain."],[9,"after","","Do whatever work this middleware needs to do with both a `Request` and `Response` objects.",41],[10,"catch","","Try to catch an error thrown by previous `AfterMiddleware`, the `Handler`, or a previous\n`BeforeMiddleware`.",41],[6,"AroundMiddleware","","AroundMiddleware are used to wrap and replace the `Handler` in a `Chain`."],[9,"around","","Produce a `Handler` from this `AroundMiddleware` given another `Handler`.",42],[6,"Handler","","`Handler`s are responsible for handling requests by creating Responses from Requests."],[9,"call","","Produce a `Response` from a Request, with the possibility of error.",43],[10,"catch","","If `Handler`'s call method produces an Err, then this method is called\nto produce a `Response` and possibly handle the error.",43],[6,"Chain","","Chain's hold `BeforeMiddleware`, a `Handler`, and `AfterMiddleware` and are responsible\nfor correctly dispatching a `Request` through them."],[9,"new","","Create a new Chain from a `Handler`.",44],[9,"link","","Link both a before and after middleware to the chain at once.",44],[9,"link_before","","Link a `BeforeMiddleware` to the Chain.",44],[9,"link_after","","Link a `AfterMiddleware` to the Chain.",44],[9,"around","","Wrap the Chain's `Handler` using an AroundMiddleware.",44],[1,"TypeMap","","A map keyed by types."],[0,"status","",""],[2,"Status","iron::status","HTTP status code"],[12,"Continue","","",36],[12,"SwitchingProtocols","","",36],[12,"Processing","","",36],[12,"Ok","","",36],[12,"Created","","",36],[12,"Accepted","","",36],[12,"NonAuthoritativeInformation","","",36],[12,"NoContent","","",36],[12,"ResetContent","","",36],[12,"PartialContent","","",36],[12,"MultiStatus","","",36],[12,"AlreadyReported","","",36],[12,"ImUsed","","",36],[12,"MultipleChoices","","",36],[12,"MovedPermanently","","",36],[12,"Found","","",36],[12,"SeeOther","","",36],[12,"NotModified","","",36],[12,"UseProxy","","",36],[12,"SwitchProxy","","",36],[12,"TemporaryRedirect","","",36],[12,"PermanentRedirect","","",36],[12,"BadRequest","","",36],[12,"Unauthorized","","",36],[12,"PaymentRequired","","",36],[12,"Forbidden","","",36],[12,"NotFound","","",36],[12,"MethodNotAllowed","","",36],[12,"NotAcceptable","","",36],[12,"ProxyAuthenticationRequired","","",36],[12,"RequestTimeout","","",36],[12,"Conflict","","",36],[12,"Gone","","",36],[12,"LengthRequired","","",36],[12,"PreconditionFailed","","",36],[12,"RequestEntityTooLarge","","",36],[12,"RequestUriTooLong","","",36],[12,"UnsupportedMediaType","","",36],[12,"RequestedRangeNotSatisfiable","","",36],[12,"ExpectationFailed","","",36],[12,"ImATeapot","","",36],[12,"AuthenticationTimeout","","",36],[12,"UnprocessableEntity","","",36],[12,"Locked","","",36],[12,"FailedDependency","","",36],[12,"MethodFailure","","",36],[12,"UnorderedCollection","","",36],[12,"UpgradeRequired","","",36],[12,"PreconditionRequired","","",36],[12,"TooManyRequests","","",36],[12,"RequestHeaderFieldsTooLarge","","",36],[12,"UnavailableForLegalReasons","","",36],[12,"InternalServerError","","",36],[12,"NotImplemented","","",36],[12,"BadGateway","","",36],[12,"ServiceUnavailable","","",36],[12,"GatewayTimeout","","",36],[12,"HttpVersionNotSupported","","",36],[12,"VariantAlsoNegotiates","","",36],[12,"InsufficientStorage","","",36],[12,"LoopDetected","","",36],[12,"NotExtended","","",36],[12,"NetworkAuthenticationRequired","","",36],[12,"UnregisteredStatus","","",36],[0,"method","iron",""],[2,"Method","iron::method","HTTP methods, as defined in RFC 2616, §5.1.1."],[12,"Options","","",13],[12,"Get","","",13],[12,"Head","","",13],[12,"Post","","",13],[12,"Put","","",13],[12,"Delete","","",13],[12,"Trace","","",13],[12,"Connect","","",13],[12,"Patch","","",13],[12,"ExtensionMethod","","",13],[0,"headers","iron","Types and utilities for working with headers in HTTP requests and responses."],[2,"HeaderLineErr","iron::headers",""],[12,"EndOfFile","","",45],[12,"EndOfHeaders","","",45],[12,"MalformedHeaderValue","","",45],[12,"MalformedHeaderSyntax","","",45],[0,"test_utils","",""],[3,"from_stream_with_str","iron::headers::test_utils",""],[3,"to_stream_into_str","",""],[3,"assert_invalid","",""],[3,"assert_conversion_correct","",""],[3,"assert_interpretation_correct","",""],[0,"serialization_utils","iron::headers","Utility functions for assisting with conversion of headers from and to the HTTP text form."],[3,"normalise_header_name","iron::headers::serialization_utils","Normalise an HTTP header name."],[3,"comma_split","","Split a value on commas, as is common for HTTP headers."],[3,"comma_split_iter","",""],[6,"WriterUtil","",""],[9,"write_maybe_quoted_string","","",46],[9,"write_quoted_string","","",46],[9,"write_parameter","","",46],[9,"write_parameters","","",46],[9,"write_quality","","",46],[9,"write_token","","",46],[3,"comma_join","","Join a vector of values with commas, as is common for HTTP headers."],[3,"push_maybe_quoted_string","","Push a ( token | quoted-string ) onto a string and return it again"],[3,"maybe_quoted_string","","Make a string into a ( token | quoted-string ), preferring a token"],[3,"push_quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"unquote_string","","Parse a quoted-string. Returns ``None`` if the string is not a valid quoted-string."],[3,"maybe_unquote_string","","Parse a ( token | quoted-string ). Returns ``None`` if it is not valid."],[3,"push_parameter","",""],[3,"push_parameters","",""],[0,"accept_ranges","iron::headers","The Accept-Ranges request header, defined in RFC 2616, Section 14.5."],[2,"RangeUnit","iron::headers::accept_ranges",""],[12,"Bytes","","",14],[12,"OtherRangeUnit","","",14],[2,"AcceptableRanges","",""],[12,"RangeUnits","","",15],[12,"NoAcceptableRanges","","",15],[0,"connection","iron::headers","The Connection general header, defined in RFC 2616, Section 14.10."],[2,"Connection","iron::headers::connection","A value for the Connection header. Note that should it be a ``Token``, the string is in\nnormalised header case (e.g. \"Keep-Alive\")."],[12,"Token","","",16],[12,"Close","","",16],[0,"content_type","iron::headers","The Content-Type entity header, defined in RFC 2616, Section 14.17."],[1,"MediaType","iron::headers::content_type",""],[11,"type_","","",17],[11,"subtype","","",17],[11,"parameters","","",17],[0,"etag","iron::headers",""],[1,"EntityTag","iron::headers::etag",""],[11,"weak","","",18],[11,"opaque_tag","","",18],[3,"weak_etag","",""],[3,"strong_etag","",""],[0,"host","iron::headers","The Host request header, defined in RFC 2616, Section 14.23."],[1,"Host","iron::headers::host","A simple little thing for the host of a request"],[11,"name","","The name of the host that was requested",19],[11,"port","","If unspecified, assume the default port was used (80 for HTTP, 443 for HTTPS).\nIn that case, you shouldn't need to worry about it in URLs that you build, provided you\ninclude the scheme.",19],[0,"transfer_encoding","iron::headers","The Transfer-Encoding request header, defined in RFC 2616, sections 14.41 and 3.6."],[2,"TransferCoding","iron::headers::transfer_encoding","RFC 2616, section 3.6:"],[12,"Chunked","","",20],[12,"TransferExtension","","",20],[4,"DeltaSeconds","iron::headers",""],[2,"ConsumeCommaLWSResult","",""],[12,"CommaConsumed","","",21],[12,"EndOfValue","","",21],[12,"ErrCommaNotFound","","",21],[6,"HeaderEnum","",""],[9,"header_name","","",47],[9,"header_value","","",47],[9,"write_header","","",47],[9,"value_from_stream","","Return values:",47],[3,"header_enum_from_stream","","Shifted out of being a default method to fix an ICE (not yet reported, TODO)"],[1,"HeaderValueByteIterator","","An iterator over the bytes of a header value.\nThis ensures one cannot read past the end of a header mistakenly and that linear white space is\nhandled correctly so that nothing else needs to worry about it. Any linear whitespace (multiple\nspaces outside of a quoted-string) is compacted into a single SP."],[11,"reader","","",23],[11,"next_byte","","This field serves two purposes. *During* iteration, it will typically be ``None``, but\ncertain cases will cause it to be a ``Some``, meaning that the next ``next()`` call will\nreturn that value rather than reading a new byte. At the *end* of iteration (after\n``next()`` has returned ``None``), it will be the extra byte which it has had to consume\nfrom the stream because of the possibility of linear white space of the form ``CR LF SP``.\nIt is guaranteed that if ``self.state == Finished`` this will be a ``Some``.",23],[11,"at_start","","",23],[6,"HeaderConvertible","","A datatype for headers."],[9,"from_stream","","Read a header value from an iterator over the raw value.",48],[9,"to_stream","","Write the HTTP value of the header to the stream.",48],[9,"http_value","","The value of the header as it would be written for an HTTP header.",48],[6,"CommaListHeaderConvertible","","A header with multiple comma-separated values. Implement this and a HeaderConvertible\nimplementation for Vec<T> is yours for free—just make sure your reading does not consume the\ncomma."],[0,"request","",""],[2,"Header","iron::headers::request",""],[12,"CacheControl","","",30],[12,"Connection","","",30],[12,"Date","","",30],[12,"Pragma","","",30],[12,"Trailer","","",30],[12,"TransferEncoding","","",30],[12,"Upgrade","","",30],[12,"Via","","",30],[12,"Warning","","",30],[12,"Accept","","",30],[12,"AcceptCharset","","",30],[12,"AcceptEncoding","","",30],[12,"AcceptLanguage","","",30],[12,"Authorization","","",30],[12,"Expect","","",30],[12,"From","","",30],[12,"Host","","",30],[12,"IfMatch","","",30],[12,"IfModifiedSince","","",30],[12,"IfNoneMatch","","",30],[12,"IfRange","","",30],[12,"IfUnmodifiedSince","","",30],[12,"MaxForwards","","",30],[12,"ProxyAuthorization","","",30],[12,"Range","","",30],[12,"Referer","","",30],[12,"Te","","",30],[12,"UserAgent","","",30],[12,"Allow","","",30],[12,"ContentEncoding","","",30],[12,"ContentLanguage","","",30],[12,"ContentLength","","",30],[12,"ContentLocation","","",30],[12,"ContentMd5","","",30],[12,"ContentRange","","",30],[12,"ContentType","","",30],[12,"Expires","","",30],[12,"LastModified","","",30],[12,"ExtensionHeader","","",30],[1,"HeaderCollection","",""],[11,"cache_control","","",28],[11,"connection","","",28],[11,"date","","",28],[11,"pragma","","",28],[11,"trailer","","",28],[11,"transfer_encoding","","",28],[11,"upgrade","","",28],[11,"via","","",28],[11,"warning","","",28],[11,"accept","","",28],[11,"accept_charset","","",28],[11,"accept_encoding","","",28],[11,"accept_language","","",28],[11,"authorization","","",28],[11,"expect","","",28],[11,"from","","",28],[11,"host","","",28],[11,"if_match","","",28],[11,"if_modified_since","","",28],[11,"if_none_match","","",28],[11,"if_range","","",28],[11,"if_unmodified_since","","",28],[11,"max_forwards","","",28],[11,"proxy_authorization","","",28],[11,"range","","",28],[11,"referer","","",28],[11,"te","","",28],[11,"user_agent","","",28],[11,"allow","","",28],[11,"content_encoding","","",28],[11,"content_language","","",28],[11,"content_length","","",28],[11,"content_location","","",28],[11,"content_md5","","",28],[11,"content_range","","",28],[11,"content_type","","",28],[11,"expires","","",28],[11,"last_modified","","",28],[11,"extensions","","",28],[1,"HeaderCollectionIterator","",""],[0,"response","iron::headers",""],[2,"Header","iron::headers::response",""],[12,"CacheControl","","",33],[12,"Connection","","",33],[12,"Date","","",33],[12,"Pragma","","",33],[12,"Trailer","","",33],[12,"TransferEncoding","","",33],[12,"Upgrade","","",33],[12,"Via","","",33],[12,"Warning","","",33],[12,"AcceptPatch","","",33],[12,"AcceptRanges","","",33],[12,"Age","","",33],[12,"ETag","","",33],[12,"Location","","",33],[12,"ProxyAuthenticate","","",33],[12,"RetryAfter","","",33],[12,"Server","","",33],[12,"Vary","","",33],[12,"WwwAuthenticate","","",33],[12,"Allow","","",33],[12,"ContentEncoding","","",33],[12,"ContentLanguage","","",33],[12,"ContentLength","","",33],[12,"ContentLocation","","",33],[12,"ContentMd5","","",33],[12,"ContentRange","","",33],[12,"ContentType","","",33],[12,"Expires","","",33],[12,"LastModified","","",33],[12,"ExtensionHeader","","",33],[1,"HeaderCollection","",""],[11,"cache_control","","",31],[11,"connection","","",31],[11,"date","","",31],[11,"pragma","","",31],[11,"trailer","","",31],[11,"transfer_encoding","","",31],[11,"upgrade","","",31],[11,"via","","",31],[11,"warning","","",31],[11,"accept_patch","","",31],[11,"accept_ranges","","",31],[11,"age","","",31],[11,"etag","","",31],[11,"location","","",31],[11,"proxy_authenticate","","",31],[11,"retry_after","","",31],[11,"server","","",31],[11,"vary","","",31],[11,"www_authenticate","","",31],[11,"allow","","",31],[11,"content_encoding","","",31],[11,"content_language","","",31],[11,"content_length","","",31],[11,"content_location","","",31],[11,"content_md5","","",31],[11,"content_range","","",31],[11,"content_type","","",31],[11,"expires","","",31],[11,"last_modified","","",31],[11,"extensions","","",31],[1,"HeaderCollectionIterator","",""],[6,"Plugin","iron","An interface for plugins that cache values between calls."],[9,"get","","Return a copy of the plugin's produced value.",49],[9,"get_ref","","Return a reference to the plugin's produced value.",49],[9,"get_mut","","Return a mutable reference to the plugin's produced value.",49],[6,"Error","",""],[9,"name","","",50],[9,"description","","",50],[9,"cause","","",50],[9,"unwrap","","",50],[9,"abstract","","",50],[6,"ErrorRefExt","",""],[9,"is","","",51],[9,"downcast","","",51],[10,"catch","","If `Handler`'s call method produces an Err, then this method is called\nto produce a `Response` and possibly handle the error.",43],[10,"catch","","Try to `catch` an error thrown by this Middleware or a previous `BeforeMiddleware`.",40],[10,"catch","","Try to catch an error thrown by previous `AfterMiddleware`, the `Handler`, or a previous\n`BeforeMiddleware`.",41]],"paths":[[1,"Request"],[1,"Url"],[1,"Response"],[1,"Iron"],[1,"TypeMap"],[1,"Request"],[1,"BufferedStream"],[1,"RequestWriter"],[1,"ResponseReader"],[2,"NetworkStream"],[1,"RequestBuffer"],[2,"RequestUri"],[1,"ResponseWriter"],[2,"Method"],[2,"RangeUnit"],[2,"AcceptableRanges"],[2,"Connection"],[1,"MediaType"],[1,"EntityTag"],[1,"Host"],[2,"TransferCoding"],[2,"ConsumeCommaLWSResult"],[2,"HeaderValueByteIteratorState"],[1,"HeaderValueByteIterator"],[1,"Vec"],[1,"String"],[1,"Url"],[1,"Tm"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[2,"ValueToken"],[2,"ValueToken"],[2,"Status"],[1,"ChainBuilder"],[1,"Box"],[1,"Arc"],[6,"BeforeMiddleware"],[6,"AfterMiddleware"],[6,"AroundMiddleware"],[6,"Handler"],[6,"Chain"],[2,"HeaderLineErr"],[6,"WriterUtil"],[6,"HeaderEnum"],[6,"HeaderConvertible"],[6,"Plugin"],[6,"Error"],[6,"ErrorRefExt"]]};
searchIndex['static_file'] = {"items":[[0,"","static_file","Static file-serving handler."],[1,"Static","","The static file-serving `Handler`."],[1,"NoFile","","The error returned when a requested URL doesn't map to a real file."],[1,"FileError","","The error returned when an IoError occurs during file serving."],[10,"clone","","",0],[10,"fmt","","",1],[10,"fmt","","",2],[10,"name","","",1],[10,"name","","",2],[10,"new","","Create a new instance of `Static` with a given root path.",0],[10,"call","","",0]],"paths":[[1,"Static"],[1,"NoFile"],[1,"FileError"]]};

searchIndex['router'] = {"items":[[0,"","router","`Router` provides a fast router handler for the Iron web framework."],[1,"Router","","`Router` provides an interface for creating complex routes as middleware\nfor the Iron framework."],[10,"new","","`new` constructs a new, blank `Router`.",0],[10,"route","","Add a new route to a `Router`, matching both a method and glob pattern.",0],[10,"get","","Like route, but specialized to the `Get` method.",0],[10,"post","","Like route, but specialized to the `Post` method.",0],[10,"put","","Like route, but specialized to the `Put` method.",0],[10,"delete","","Like route, but specialized to the `Delete` method.",0],[10,"head","","Like route, but specialized to the `Head` method.",0],[10,"patch","","Like route, but specialized to the `Patch` method.",0],[10,"options","","Like route, but specialized to the `Options` method.",0],[10,"error","","Add a Handler to be used for this Router's `catch` method.",0],[10,"call","","",0],[10,"catch","","",0],[10,"new","route-recognizer","",1],[10,"insert","","",1],[10,"find","","",1],[10,"clone","route-recognizer::nfa","",2],[10,"clone_from","","",2],[10,"assert_receiver_is_total_eq","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"ne","","",2],[10,"new","","",2],[10,"insert","","",2],[10,"contains","","",2],[10,"clone","","",3],[10,"clone_from","","",3],[10,"assert_receiver_is_total_eq","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"ne","","",3],[10,"any","","",3],[10,"valid","","",3],[10,"invalid","","",3],[10,"valid_char","","",3],[10,"invalid_char","","",3],[10,"matches","","",3],[10,"clone","","",4],[10,"clone_from","","",4],[10,"new","","",4],[10,"start_capture","","",4],[10,"end_capture","","",4],[10,"extract","","",4],[10,"clone","","",5],[10,"clone_from","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"new","","",5],[10,"new","","",6],[10,"clone","","",7],[10,"clone_from","","",7],[10,"new","","",7],[10,"process","","",7],[10,"get","","",7],[10,"get_mut","","",7],[10,"put","","",7],[10,"put_state","","",7],[10,"acceptance","","",7],[10,"start_capture","","",7],[10,"end_capture","","",7],[10,"metadata","","",7],[10,"clone","route-recognizer","",8],[10,"clone_from","","",8],[10,"new","","",8],[10,"cmp","","",8],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"assert_receiver_is_total_eq","","",8],[10,"fmt","","",1],[10,"clone","","",1],[10,"clone_from","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"ne","","",1],[10,"index","","",1],[10,"new","","",9],[10,"clone","","",10],[10,"clone_from","","",10],[10,"new","","",10],[10,"add","","",10],[10,"recognize","","",10],[1,"Params","router",""]],"paths":[[1,"Router"],[1,"Params"],[1,"CharSet"],[2,"CharacterClass"],[1,"Thread"],[1,"State"],[1,"Match"],[1,"NFA"],[1,"Metadata"],[1,"Match"],[1,"Router"]]};

searchIndex['persistent'] = {"items":[[0,"","persistent","A set of middleware for sharing data between requests in the Iron\nframework."],[1,"State","","Middleware for data that persists between requests with read and write capabilities."],[1,"Read","","Middleware for data that persists between Requests with read-only capabilities."],[1,"Write","","Middleware for data that persists between Requests for data which mostly\nneeds to be written instead of read."],[10,"clone","","",0],[10,"clone","","",1],[10,"clone","","",2],[10,"eval","","",1],[10,"eval","","",0],[10,"eval","","",2],[10,"before","","",1],[10,"after","","",1],[10,"before","","",0],[10,"after","","",0],[10,"before","","",2],[10,"after","","",2],[10,"both","","Construct a new pair of `State` that can be passed directly to `Chain::link`.",1],[10,"one","","Construct a new `State` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",1],[10,"both","","Construct a new pair of `Read` that can be passed directly to `Chain::link`.",0],[10,"one","","Construct a new `Read` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",0],[10,"both","","Construct a new pair of `Write` that can be passed directly to `Chain::link`.",2],[10,"one","","Construct a new `Write` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",2]],"paths":[[1,"Read"],[1,"State"],[1,"Write"]]};

searchIndex['lib'] = {"items":[[0,"","lib","A set of middleware for sharing data between requests in the Iron\nframework."],[1,"State","","Middleware for data that persists between requests with read and write capabilities."],[1,"Read","","Middleware for data that persists between Requests with read-only capabilities."],[1,"Write","","Middleware for data that persists between Requests for data which mostly\nneeds to be written instead of read."],[10,"clone","","",0],[10,"clone","","",1],[10,"clone","","",2],[10,"eval","","",1],[10,"eval","","",0],[10,"eval","","",2],[10,"before","","",1],[10,"after","","",1],[10,"before","","",0],[10,"after","","",0],[10,"before","","",2],[10,"after","","",2],[10,"both","","Construct a new pair of `State` that can be passed directly to `Chain::link`.",1],[10,"one","","Construct a new `State` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",1],[10,"both","","Construct a new pair of `Read` that can be passed directly to `Chain::link`.",0],[10,"one","","Construct a new `Read` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",0],[10,"both","","Construct a new pair of `Write` that can be passed directly to `Chain::link`.",2],[10,"one","","Construct a new `Write` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",2]],"paths":[[1,"Read"],[1,"State"],[1,"Write"]]};

searchIndex['mount'] = {"items":[[0,"","mount","`Mount` provides mounting middleware for the Iron framework."],[1,"Mount","","`Mount` is a simple mounting middleware."],[1,"OriginalUrl","","Exposes the original, unmodified path to be stored in `Request::extensions`."],[10,"new","","Creates a new instance of `Mount`.",0],[10,"mount","","Mounts a given `Handler` onto a route.",0],[10,"call","","",0]],"paths":[[1,"Mount"]]};

searchIndex['urlencoded'] = {"items":[[0,"","urlencoded","URL Encoded Plugin for Iron."],[1,"UrlEncodedQuery","","Plugin for `Request` that extracts URL encoded data from the URL query string."],[1,"UrlEncodedBody","","Plugin for `Request` that extracts URL encoded data from the request body."],[4,"QueryMap","","Hashmap mapping strings to vectors of strings."],[10,"eval","","",0],[10,"eval","","",1]],"paths":[[1,"UrlEncodedQuery"],[1,"UrlEncodedBody"]]};

searchIndex['staticfile'] = {"items":[[0,"","staticfile","Static file-serving middleware."],[1,"Static","","The static file-serving `Middleware`."],[10,"clone","","",0],[10,"new","","Create a new instance of `Static` with a given root path.",0],[10,"favicon","","Create a favicon server from the given filepath.",0],[10,"enter","","",0]],"paths":[[1,"Static"]]};

initSearch(searchIndex);

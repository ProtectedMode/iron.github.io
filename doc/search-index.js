var searchIndex = {};
searchIndex['mount'] = {"items":[[0,"","mount","`Mount` provides mounting middleware for the Iron framework."],[1,"Mount","","`Mount` is a simple mounting middleware."],[1,"OriginalUrl","","Exposes the original, unmodified path to be stored in `Request::extensions`."],[10,"new","","Creates a new instance of `Mount`.",0],[10,"mount","","Mounts a given `Handler` onto a route.",0],[10,"call","","",0]],"paths":[[1,"Mount"]]};
searchIndex['iron'] = {"items":[[0,"","iron","The main crate for the Iron library."],[1,"Request","","The `Request` given to all `Middleware`."],[11,"url","","The requested URL.",0],[11,"remote_addr","","The originating address of the request.",0],[11,"headers","","The request headers.",0],[11,"body","","The request body.",0],[11,"method","","The request method.",0],[11,"extensions","","Extensible storage for data passed between middleware.",0],[1,"Url","","HTTP/HTTPS URL type for Iron."],[11,"scheme","","The lower-cased scheme of the URL, typically \"http\" or \"https\".",1],[11,"host","","The host field of the URL, probably a domain.",1],[11,"port","","The connection port.",1],[11,"path","","The URL path, the resource to be accessed.",1],[11,"username","","The URL username field, from the userinfo section of the URL.",1],[11,"password","","The URL password field, from the userinfo section of the URL.",1],[11,"query","","The URL query string.",1],[11,"fragment","","The URL fragment.",1],[1,"Iron","","The primary entrance point to `Iron`, a `struct` to instantiate a new server."],[11,"handler","","Iron contains a `Handler`, which it uses to create responses for client\nrequests.",2],[0,"prelude","","A module meant to be glob imported when using Iron, for instance:"],[6,"Set","iron::prelude","A blanket trait providing the set and set_mut methods for all types."],[9,"set","","Modify self using the provided modifier.",3],[9,"set_mut","","Modify self through a mutable reference with the provided modifier.",3],[6,"GetCached","","An interface for plugins that cache values between calls."],[9,"get","","Return a copy of the plugin's produced value.",4],[9,"get_ref","","Return a reference to the plugin's produced value.",4],[9,"get_mut","","Return a mutable reference to the plugin's produced value.",4],[6,"ErrorRefExt","",""],[9,"is","","",5],[9,"downcast","","",5],[0,"typemap","iron","Re-exports from the TypeMap crate."],[10,"new","typemap","Create a new, empty TypeMap.",6],[10,"insert","","Insert a value into the map with a specified key type.",6],[10,"find","","Find a value in the map and get a reference to it.",6],[10,"find_mut","","Find a value in the map and get a mutable reference to it.",6],[10,"get","","Find a value in the map and get a reference to it.",6],[10,"get_mut","","Find a value in the map and get a mutable reference to it.",6],[10,"contains","","Check if a key has an associated value stored in the map.",6],[10,"remove","","Remove a value from the map.",6],[10,"entry","","Get the given key's corresponding entry in the map for in-place manipulation.",6],[10,"data","","Read the underlying HashMap",6],[10,"data_mut","","Get a mutable reference to the underlying HashMap",6],[10,"len","","Get the number of values stored in the map.",6],[10,"is_empty","","Return true if the map contains no values.",6],[10,"clear","","Remove all entries from the map.",6],[10,"default","","",6],[10,"get","","Get a reference to the entry's value.",7],[10,"get_mut","","Get a mutable reference to the entry's value.",7],[10,"into_mut","","Transform the entry into a mutable reference with the same lifetime as the map.",7],[10,"set","","Set the entry's value and return the previous value.",7],[10,"take","","Move the entry's value out of the map, consuming the entry.",7],[10,"set","","Set the entry's value and return a mutable reference to it.",8],[1,"TypeMap","iron::typemap","A map keyed by types."],[6,"Assoc","","This trait defines the relationship between keys and values in a TypeMap."],[0,"modifier","iron","Re-exports from the Modifier crate."],[6,"Set","iron::modifier","A blanket trait providing the set and set_mut methods for all types."],[9,"set","","Modify self using the provided modifier.",3],[9,"set_mut","","Modify self through a mutable reference with the provided modifier.",3],[6,"Modifier","","Allows use of the implemented type as an argument to Set::set."],[9,"modify","","Modify `F` with self.",9],[0,"middleware","iron","Iron's Middleware and Handler System"],[1,"ChainBuilder","iron::middleware","The default Chain used in Iron."],[6,"Handler","","`Handler`s are responsible for handling requests by creating Responses from Requests."],[9,"call","","Produce a `Response` from a Request, with the possibility of error.",10],[10,"catch","","If `Handler`'s call method produces an Err, then this method is called\nto produce a `Response` and possibly handle the error.",10],[6,"BeforeMiddleware","","`BeforeMiddleware` are fired before a `Handler` is called inside of a Chain."],[9,"before","","Do whatever work this middleware should do with a `Request` object.",11],[10,"catch","","Try to `catch` an error thrown by this Middleware or a previous `BeforeMiddleware`.",11],[6,"AfterMiddleware","","`AfterMiddleware` are fired after a `Handler` is called inside of a Chain."],[9,"after","","Do whatever work this middleware needs to do with both a `Request` and `Response` objects.",12],[10,"catch","","Try to catch an error thrown by previous `AfterMiddleware`, the `Handler`, or a previous\n`BeforeMiddleware`.",12],[6,"AroundMiddleware","","AroundMiddleware are used to wrap and replace the `Handler` in a `Chain`."],[9,"around","","Produce a `Handler` from this `AroundMiddleware` given another `Handler`.",13],[6,"Chain","","Chain's hold `BeforeMiddleware`, a `Handler`, and `AfterMiddleware` and are responsible\nfor correctly dispatching a `Request` through them."],[9,"new","","Create a new Chain from a `Handler`.",14],[9,"link","","Link both a before and after middleware to the chain at once.",14],[9,"link_before","","Link a `BeforeMiddleware` to the Chain.",14],[9,"link_after","","Link a `AfterMiddleware` to the Chain.",14],[9,"around","","Wrap the Chain's `Handler` using an AroundMiddleware.",14],[10,"new","","Construct a new ChainBuilder from a `Handler`.",15],[10,"new","","",15],[10,"link","","",15],[10,"link_before","","",15],[10,"link_after","","",15],[10,"around","","",15],[10,"call","","",15],[10,"catch","","",15],[10,"call","alloc::boxed","",16],[10,"catch","","",16],[10,"call","alloc::arc","",17],[10,"catch","","",17],[0,"errors","iron","Some common error types for use within Iron and in downstream middleware."],[1,"FileError","iron::errors","The standard Error implementation used to wrap IoErrors\nthat occur when reading or writing files or otherwise\ninteracting with the file system."],[10,"eq","","",18],[10,"ne","","",18],[10,"clone","","",18],[10,"fmt","","",18],[10,"new","","Create a new FileError from an IoError.",18],[10,"unwrap","","Access the original IoError.",18],[10,"name","","",18],[10,"description","","",18],[0,"response","iron","Iron's HTTP Response representation and associated methods."],[1,"Response","iron::response","The response representation given to `Middleware`"],[11,"body","","The body of the response.",19],[11,"headers","","The headers of the response.",19],[11,"status","","The response status-code.",19],[11,"extensions","","A TypeMap to be used as an extensible storage for data\nassociated with this Response.",19],[0,"modifiers","","Defines a series of convenience modifiers for editing Responses"],[1,"ContentType","iron::response::modifiers","A response modifier for setting the content-type header."],[1,"Body","","A response modifier for setting the body of a response."],[1,"Status","","A modifier for setting the status of a response."],[1,"Redirect","","A modifier for creating redirect responses."],[6,"Bodyable","","Something that can be used to set the body of a response."],[9,"set_body","","Set the body of this response, possibly also setting headers.",20],[10,"new","","Create a new ContentType modifier from the parts of a content-type header value.",21],[10,"modify","","",21],[10,"modify","","",22],[10,"set_body","alloc::boxed","",16],[10,"set_body","collections::string","",23],[10,"set_body","collections::vec","",24],[10,"set_body","std::io::fs","",25],[10,"set_body","std::path::posix","Set the body to the contents of the File at this path.",26],[10,"modify","iron::response::modifiers","",27],[10,"modify","","",28],[10,"new","iron::response","Construct a blank Response",19],[10,"status","","Create a new response with the status.",19],[10,"with","","Create a new response with the specified body and status.",19],[10,"redirect","","Create a new Response with the `location` header set to the specified url.",19],[10,"from_file","","Create a response from a file on disk.",19],[10,"fmt","","",19],[10,"extensions","","",19],[10,"extensions_mut","","",19],[10,"new","http::server::response","Create a `ResponseWriter` writing to the specified location",29],[10,"write_content_auto","","Write a response with the specified Content-Type and content; the Content-Length header is\nset based upon the contents",29],[10,"try_write_headers","","Write the Status-Line and headers of the response, if we have not already done so.",29],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",29],[10,"finish_response","","",29],[10,"new","http::buffer","",30],[10,"poke_byte","","Poke a single byte back so it will be read next. For this to make sense, you must have just\nread that byte. If `self.pos` is 0 and `self.max` is not 0 (i.e. if the buffer is just\nfilled\nVery great caution must be used in calling this as it will fail if `self.pos` is 0.",30],[10,"read_byte","","Slightly faster implementation of read_byte than that which is provided by ReaderUtil\n(which just uses `read()`)",30],[10,"finish_response","","Finish off writing a response: this flushes the writer and in case of chunked\nTransfer-Encoding writes the ending zero-length chunk to indicate completion.",30],[10,"read","","Read at most N bytes into `buf`, where N is the minimum of `buf.len()` and the buffer size.",30],[10,"read_at_least","","",30],[10,"read_byte","","",30],[10,"push","","",30],[10,"push_at_least","","",30],[10,"read_exact","","",30],[10,"read_to_end","","",30],[10,"read_to_string","","",30],[10,"read_le_uint_n","","",30],[10,"read_le_int_n","","",30],[10,"read_be_uint_n","","",30],[10,"read_be_int_n","","",30],[10,"read_le_uint","","",30],[10,"read_le_int","","",30],[10,"read_be_uint","","",30],[10,"read_be_int","","",30],[10,"read_be_u64","","",30],[10,"read_be_u32","","",30],[10,"read_be_u16","","",30],[10,"read_be_i64","","",30],[10,"read_be_i32","","",30],[10,"read_be_i16","","",30],[10,"read_be_f64","","",30],[10,"read_be_f32","","",30],[10,"read_le_u64","","",30],[10,"read_le_u32","","",30],[10,"read_le_u16","","",30],[10,"read_le_i64","","",30],[10,"read_le_i32","","",30],[10,"read_le_i16","","",30],[10,"read_le_f64","","",30],[10,"read_le_f32","","",30],[10,"read_u8","","",30],[10,"read_i8","","",30],[10,"write","","",30],[10,"flush","","",30],[10,"flush","","",30],[10,"write_fmt","","",30],[10,"write_str","","",30],[10,"write_line","","",30],[10,"write_char","","",30],[10,"write_int","","",30],[10,"write_uint","","",30],[10,"write_le_uint","","",30],[10,"write_le_int","","",30],[10,"write_be_uint","","",30],[10,"write_be_int","","",30],[10,"write_be_u64","","",30],[10,"write_be_u32","","",30],[10,"write_be_u16","","",30],[10,"write_be_i64","","",30],[10,"write_be_i32","","",30],[10,"write_be_i16","","",30],[10,"write_be_f64","","",30],[10,"write_be_f32","","",30],[10,"write_le_u64","","",30],[10,"write_le_u32","","",30],[10,"write_le_u16","","",30],[10,"write_le_i64","","",30],[10,"write_le_i32","","",30],[10,"write_le_i16","","",30],[10,"write_le_f64","","",30],[10,"write_le_f32","","",30],[10,"write_u8","","",30],[10,"write_i8","","",30],[10,"new","http::client::request","Create a `RequestWriter` writing to the specified location",31],[10,"new_request","","",31],[10,"try_connect","","Connect to the remote host if not already connected.",31],[10,"connect","","Connect to the remote host; fails if already connected.\nReturns ``true`` upon success and ``false`` upon failure (also use conditions).",31],[10,"try_write_headers","","Write the Request-Line and headers of the response, if we have not already done so.",31],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",31],[10,"read_response","","Send the request and construct a `ResponseReader` out of it.",31],[10,"write","","",31],[10,"flush","","",31],[10,"flush","","",31],[10,"write_fmt","","",31],[10,"write_str","","",31],[10,"write_line","","",31],[10,"write_char","","",31],[10,"write_int","","",31],[10,"write_uint","","",31],[10,"write_le_uint","","",31],[10,"write_le_int","","",31],[10,"write_be_uint","","",31],[10,"write_be_int","","",31],[10,"write_be_u64","","",31],[10,"write_be_u32","","",31],[10,"write_be_u16","","",31],[10,"write_be_i64","","",31],[10,"write_be_i32","","",31],[10,"write_be_i16","","",31],[10,"write_be_f64","","",31],[10,"write_be_f32","","",31],[10,"write_le_u64","","",31],[10,"write_le_u32","","",31],[10,"write_le_u16","","",31],[10,"write_le_i64","","",31],[10,"write_le_i32","","",31],[10,"write_le_i16","","",31],[10,"write_le_f64","","",31],[10,"write_le_f32","","",31],[10,"write_u8","","",31],[10,"write_i8","","",31],[10,"construct","http::client::response","",32],[10,"read","","",32],[10,"read_at_least","","",32],[10,"read_byte","","",32],[10,"push","","",32],[10,"push_at_least","","",32],[10,"read_exact","","",32],[10,"read_to_end","","",32],[10,"read_to_string","","",32],[10,"read_le_uint_n","","",32],[10,"read_le_int_n","","",32],[10,"read_be_uint_n","","",32],[10,"read_be_int_n","","",32],[10,"read_le_uint","","",32],[10,"read_le_int","","",32],[10,"read_be_uint","","",32],[10,"read_be_int","","",32],[10,"read_be_u64","","",32],[10,"read_be_u32","","",32],[10,"read_be_u16","","",32],[10,"read_be_i64","","",32],[10,"read_be_i32","","",32],[10,"read_be_i16","","",32],[10,"read_be_f64","","",32],[10,"read_be_f32","","",32],[10,"read_le_u64","","",32],[10,"read_le_u32","","",32],[10,"read_le_u16","","",32],[10,"read_le_i64","","",32],[10,"read_le_i32","","",32],[10,"read_le_i16","","",32],[10,"read_le_f64","","",32],[10,"read_le_f32","","",32],[10,"read_u8","","",32],[10,"read_i8","","",32],[10,"connect","http::client::sslclients::openssl","",33],[10,"read","","",33],[10,"read_at_least","","",33],[10,"read_byte","","",33],[10,"push","","",33],[10,"push_at_least","","",33],[10,"read_exact","","",33],[10,"read_to_end","","",33],[10,"read_to_string","","",33],[10,"read_le_uint_n","","",33],[10,"read_le_int_n","","",33],[10,"read_be_uint_n","","",33],[10,"read_be_int_n","","",33],[10,"read_le_uint","","",33],[10,"read_le_int","","",33],[10,"read_be_uint","","",33],[10,"read_be_int","","",33],[10,"read_be_u64","","",33],[10,"read_be_u32","","",33],[10,"read_be_u16","","",33],[10,"read_be_i64","","",33],[10,"read_be_i32","","",33],[10,"read_be_i16","","",33],[10,"read_be_f64","","",33],[10,"read_be_f32","","",33],[10,"read_le_u64","","",33],[10,"read_le_u32","","",33],[10,"read_le_u16","","",33],[10,"read_le_i64","","",33],[10,"read_le_i32","","",33],[10,"read_le_i16","","",33],[10,"read_le_f64","","",33],[10,"read_le_f32","","",33],[10,"read_u8","","",33],[10,"read_i8","","",33],[10,"write","","",33],[10,"flush","","",33],[10,"flush","","",33],[10,"write_fmt","","",33],[10,"write_str","","",33],[10,"write_line","","",33],[10,"write_char","","",33],[10,"write_int","","",33],[10,"write_uint","","",33],[10,"write_le_uint","","",33],[10,"write_le_int","","",33],[10,"write_be_uint","","",33],[10,"write_be_int","","",33],[10,"write_be_u64","","",33],[10,"write_be_u32","","",33],[10,"write_be_u16","","",33],[10,"write_be_i64","","",33],[10,"write_be_i32","","",33],[10,"write_be_i16","","",33],[10,"write_be_f64","","",33],[10,"write_be_f32","","",33],[10,"write_le_u64","","",33],[10,"write_le_u32","","",33],[10,"write_le_u16","","",33],[10,"write_le_i64","","",33],[10,"write_le_i32","","",33],[10,"write_le_i16","","",33],[10,"write_le_f64","","",33],[10,"write_le_f32","","",33],[10,"write_u8","","",33],[10,"write_i8","","",33],[10,"new","http::server::request","",34],[10,"read_request_line","","",34],[10,"read_header","","Read a header (name, value) pair.",34],[10,"read","","",34],[10,"read_at_least","","",34],[10,"read_byte","","",34],[10,"push","","",34],[10,"push_at_least","","",34],[10,"read_exact","","",34],[10,"read_to_end","","",34],[10,"read_to_string","","",34],[10,"read_le_uint_n","","",34],[10,"read_le_int_n","","",34],[10,"read_be_uint_n","","",34],[10,"read_be_int_n","","",34],[10,"read_le_uint","","",34],[10,"read_le_int","","",34],[10,"read_be_uint","","",34],[10,"read_be_int","","",34],[10,"read_be_u64","","",34],[10,"read_be_u32","","",34],[10,"read_be_u16","","",34],[10,"read_be_i64","","",34],[10,"read_be_i32","","",34],[10,"read_be_i16","","",34],[10,"read_be_f64","","",34],[10,"read_be_f32","","",34],[10,"read_le_u64","","",34],[10,"read_le_u32","","",34],[10,"read_le_u16","","",34],[10,"read_le_i64","","",34],[10,"read_le_i32","","",34],[10,"read_le_i16","","",34],[10,"read_le_f64","","",34],[10,"read_le_f32","","",34],[10,"read_u8","","",34],[10,"read_i8","","",34],[10,"assert_receiver_is_total_eq","","",35],[10,"eq","","",35],[10,"ne","","",35],[10,"ne","","",35],[10,"fmt","","",35],[10,"load","","Get a response from an open socket.",36],[10,"write","http::server::response","",29],[10,"flush","","",29],[10,"flush","","",29],[10,"write_fmt","","",29],[10,"write_str","","",29],[10,"write_line","","",29],[10,"write_char","","",29],[10,"write_int","","",29],[10,"write_uint","","",29],[10,"write_le_uint","","",29],[10,"write_le_int","","",29],[10,"write_be_uint","","",29],[10,"write_be_int","","",29],[10,"write_be_u64","","",29],[10,"write_be_u32","","",29],[10,"write_be_u16","","",29],[10,"write_be_i64","","",29],[10,"write_be_i32","","",29],[10,"write_be_i16","","",29],[10,"write_be_f64","","",29],[10,"write_be_f32","","",29],[10,"write_le_u64","","",29],[10,"write_le_u32","","",29],[10,"write_le_u16","","",29],[10,"write_le_i64","","",29],[10,"write_le_i32","","",29],[10,"write_le_i16","","",29],[10,"write_le_f64","","",29],[10,"write_le_f32","","",29],[10,"write_u8","","",29],[10,"write_i8","","",29],[10,"hash","http::method","",37],[10,"clone","","",37],[10,"clone_from","","",37],[10,"assert_receiver_is_total_eq","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"ne","","",37],[10,"from_str","","Get a *known* `Method` from an *ASCII* string, regardless of case.",37],[10,"fmt","","",37],[10,"from_str_or_new","","Get a `Method` from an *ASCII* string.",37],[10,"assert_receiver_is_total_eq","http::headers::accept_ranges","",38],[10,"eq","","",38],[10,"ne","","",38],[10,"ne","","",38],[10,"clone","","",38],[10,"clone_from","","",38],[10,"assert_receiver_is_total_eq","","",39],[10,"eq","","",39],[10,"ne","","",39],[10,"ne","","",39],[10,"clone","","",39],[10,"clone_from","","",39],[10,"from_stream","","",39],[10,"to_stream","","",39],[10,"http_value","","",39],[10,"to_stream","","",39],[10,"assert_receiver_is_total_eq","http::headers::connection","",40],[10,"eq","","",40],[10,"ne","","",40],[10,"ne","","",40],[10,"clone","","",40],[10,"clone_from","","",40],[10,"fmt","","",40],[10,"from_stream","","",40],[10,"to_stream","","",40],[10,"http_value","","",40],[10,"to_stream","","",40],[10,"assert_receiver_is_total_eq","http::headers::content_type","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"ne","","",41],[10,"clone","","",41],[10,"clone_from","","",41],[10,"new","","",41],[10,"fmt","","",41],[10,"from_stream","","",41],[10,"to_stream","","",41],[10,"http_value","","",41],[10,"to_stream","","",41],[10,"assert_receiver_is_total_eq","http::headers::etag","",42],[10,"eq","","",42],[10,"ne","","",42],[10,"ne","","",42],[10,"clone","","",42],[10,"clone_from","","",42],[10,"fmt","","",42],[10,"from_stream","","",42],[10,"to_stream","","",42],[10,"http_value","","",42],[10,"to_stream","","",42],[10,"assert_receiver_is_total_eq","http::headers::host","",43],[10,"eq","","",43],[10,"ne","","",43],[10,"ne","","",43],[10,"clone","","",43],[10,"clone_from","","",43],[10,"fmt","","",43],[10,"from_stream","","",43],[10,"http_value","","",43],[10,"to_stream","","",43],[10,"assert_receiver_is_total_eq","http::headers::transfer_encoding","",44],[10,"eq","","",44],[10,"ne","","",44],[10,"ne","","",44],[10,"clone","","",44],[10,"clone_from","","",44],[10,"from_stream","","",44],[10,"to_stream","","",44],[10,"http_value","","",44],[10,"to_stream","","",44],[10,"assert_receiver_is_total_eq","http::headers","",45],[10,"eq","","",45],[10,"ne","","",45],[10,"ne","","",45],[10,"clone","","",45],[10,"clone_from","","",45],[10,"assert_receiver_is_total_eq","","",46],[10,"eq","","",46],[10,"ne","","",46],[10,"ne","","",46],[10,"new","","",47],[10,"verify_consumed","","Check that the entire header value has been consumed.",47],[10,"some_if_consumed","","Turn a constructed header value into an Option: Some(value) if the header value is consumed\nor None if it is not, thus indicating: \"I'm finished and expect nothing more. Anything more\nis an error.\"",47],[10,"consume_optional_lws","","Consume optional `*LWS`. That is, zero or more of SP and HT, until it\ngets to something other than SP and HT or gets to the end of the header.",47],[10,"consume_lws","","Consume `1*LWS`. That is, one or more of SP and HT, until it gets to\nsomething other than SP and HT or gets to the end of the header.",47],[10,"consume_comma_lws","","Return values:\n- CommaConsumed if there was a comma and it was consumed;\n- EndOfValue if the header value has been completely consumed;\n- ErrCommaNotFound if the next thing wasn't a comma (this is an error state)",47],[10,"read_quoted_string","","Read a quoted-string from the current position.\nIf the quoted-string is not begun immediately or the header ends before it is completed,\nthen None is returned; TODO: decide if I can return the bytes read (at present, escapes and\ndouble quote would be lost if I did that).",47],[10,"read_token_or_quoted_string","","Read a token (RFC 2616 definition) from the header value.",47],[10,"read_token","","Read a token (RFC 2616 definition) from the header value.",47],[10,"next","","",47],[10,"size_hint","","",47],[10,"chain","","",47],[10,"zip","","",47],[10,"map","","",47],[10,"filter","","",47],[10,"filter_map","","",47],[10,"enumerate","","",47],[10,"peekable","","",47],[10,"skip_while","","",47],[10,"take_while","","",47],[10,"skip","","",47],[10,"take","","",47],[10,"scan","","",47],[10,"flat_map","","",47],[10,"fuse","","",47],[10,"inspect","","",47],[10,"by_ref","","",47],[10,"collect","","",47],[10,"nth","","",47],[10,"last","","",47],[10,"fold","","",47],[10,"count","","",47],[10,"all","","",47],[10,"any","","",47],[10,"find","","",47],[10,"position","","",47],[10,"max_by","","",47],[10,"min_by","","",47],[10,"from_stream","collections::vec","",24],[10,"to_stream","","",24],[10,"http_value","","",24],[10,"to_stream","","",24],[10,"from_stream","collections::string","",23],[10,"to_stream","","",23],[10,"http_value","","",23],[10,"to_stream","","",23],[10,"from_stream","url","",48],[10,"http_value","","",48],[10,"to_stream","","",48],[10,"from_stream","http::method","",37],[10,"http_value","","",37],[10,"to_stream","","",37],[10,"from_stream","time","",49],[10,"http_value","","",49],[10,"to_stream","","",49],[10,"clone","http::headers::request","",50],[10,"clone_from","","",50],[10,"new","","",50],[10,"insert","","Consume a header, putting it into this structure.",50],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",50],[10,"iter","","",50],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",50],[10,"next","","",51],[10,"size_hint","","",51],[10,"chain","","",51],[10,"zip","","",51],[10,"map","","",51],[10,"filter","","",51],[10,"filter_map","","",51],[10,"enumerate","","",51],[10,"peekable","","",51],[10,"skip_while","","",51],[10,"take_while","","",51],[10,"skip","","",51],[10,"take","","",51],[10,"scan","","",51],[10,"flat_map","","",51],[10,"fuse","","",51],[10,"inspect","","",51],[10,"by_ref","","",51],[10,"collect","","",51],[10,"nth","","",51],[10,"last","","",51],[10,"fold","","",51],[10,"count","","",51],[10,"all","","",51],[10,"any","","",51],[10,"find","","",51],[10,"position","","",51],[10,"max_by","","",51],[10,"min_by","","",51],[10,"header_name","","",52],[10,"header_value","","",52],[10,"write_header","","",52],[10,"value_from_stream","","",52],[10,"clone","http::headers::response","",53],[10,"clone_from","","",53],[10,"new","","",53],[10,"insert","","Consume a header, putting it into this structure.",53],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",53],[10,"iter","","",53],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",53],[10,"next","","",54],[10,"size_hint","","",54],[10,"chain","","",54],[10,"zip","","",54],[10,"map","","",54],[10,"filter","","",54],[10,"filter_map","","",54],[10,"enumerate","","",54],[10,"peekable","","",54],[10,"skip_while","","",54],[10,"take_while","","",54],[10,"skip","","",54],[10,"take","","",54],[10,"scan","","",54],[10,"flat_map","","",54],[10,"fuse","","",54],[10,"inspect","","",54],[10,"by_ref","","",54],[10,"collect","","",54],[10,"nth","","",54],[10,"last","","",54],[10,"fold","","",54],[10,"count","","",54],[10,"all","","",54],[10,"any","","",54],[10,"find","","",54],[10,"position","","",54],[10,"max_by","","",54],[10,"min_by","","",54],[10,"header_name","","",55],[10,"header_value","","",55],[10,"write_header","","",55],[10,"value_from_stream","","",55],[10,"fmt","http::rfc2616","",56],[10,"from_str","","",56],[10,"fmt","","",57],[10,"from_str","","",57],[10,"clone","http::status","",58],[10,"clone_from","","",58],[10,"eq","","",58],[10,"ne","","",58],[10,"ne","","",58],[10,"assert_receiver_is_total_eq","","",58],[10,"code","","Get the status code",58],[10,"reason","","Get the reason phrase",58],[10,"from_code_and_reason","","Get a status from the code and reason",58],[10,"fmt","","",58],[10,"to_i64","","Equivalent to `Some(self.code() as i64)`",58],[10,"to_u64","","Equivalent to `Some(self.code() as u64)`",58],[10,"to_int","","",58],[10,"to_i8","","",58],[10,"to_i16","","",58],[10,"to_i32","","",58],[10,"to_uint","","",58],[10,"to_u8","","",58],[10,"to_u16","","",58],[10,"to_u32","","",58],[10,"to_f32","","",58],[10,"to_f64","","",58],[10,"from_i64","","Get a *registered* status code from the number of its status code.",58],[10,"from_u64","","Get a *registered* status code from the number of its status code.",58],[10,"from_int","","",58],[10,"from_i8","","",58],[10,"from_i16","","",58],[10,"from_i32","","",58],[10,"from_uint","","",58],[10,"from_u8","","",58],[10,"from_u16","","",58],[10,"from_u32","","",58],[10,"from_f32","","",58],[10,"from_f64","","",58],[1,"HttpResponse","iron::response",""],[11,"headers","","",29],[11,"status","","",29],[10,"clone","iron","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"parse","","Create a URL from a string.",1],[10,"from_generic_url","","Create a `Url` from a `rust-url` `Url`.",1],[10,"into_generic_url","","Create a `rust-url` `Url` from a `Url`.",1],[10,"fmt","","",1],[10,"encode","","",1],[10,"decode","","",1],[10,"fmt","","",0],[10,"from_http","","Create a request from an HttpRequest.",0],[10,"extensions","","",0],[10,"extensions_mut","","",0],[10,"listen","","Kick off the server process.",2],[10,"listen_with","","Kick off the server process with X threads.",2],[10,"new","","Instantiate a new instance of `Iron`.",2],[4,"IronError","",""],[4,"IronResult","",""],[1,"TypeMap","","A map keyed by types."],[0,"status","",""],[2,"Status","iron::status","HTTP status code"],[12,"Continue","","",58],[12,"SwitchingProtocols","","",58],[12,"Processing","","",58],[12,"Ok","","",58],[12,"Created","","",58],[12,"Accepted","","",58],[12,"NonAuthoritativeInformation","","",58],[12,"NoContent","","",58],[12,"ResetContent","","",58],[12,"PartialContent","","",58],[12,"MultiStatus","","",58],[12,"AlreadyReported","","",58],[12,"ImUsed","","",58],[12,"MultipleChoices","","",58],[12,"MovedPermanently","","",58],[12,"Found","","",58],[12,"SeeOther","","",58],[12,"NotModified","","",58],[12,"UseProxy","","",58],[12,"SwitchProxy","","",58],[12,"TemporaryRedirect","","",58],[12,"PermanentRedirect","","",58],[12,"BadRequest","","",58],[12,"Unauthorized","","",58],[12,"PaymentRequired","","",58],[12,"Forbidden","","",58],[12,"NotFound","","",58],[12,"MethodNotAllowed","","",58],[12,"NotAcceptable","","",58],[12,"ProxyAuthenticationRequired","","",58],[12,"RequestTimeout","","",58],[12,"Conflict","","",58],[12,"Gone","","",58],[12,"LengthRequired","","",58],[12,"PreconditionFailed","","",58],[12,"RequestEntityTooLarge","","",58],[12,"RequestUriTooLong","","",58],[12,"UnsupportedMediaType","","",58],[12,"RequestedRangeNotSatisfiable","","",58],[12,"ExpectationFailed","","",58],[12,"ImATeapot","","",58],[12,"AuthenticationTimeout","","",58],[12,"UnprocessableEntity","","",58],[12,"Locked","","",58],[12,"FailedDependency","","",58],[12,"MethodFailure","","",58],[12,"UnorderedCollection","","",58],[12,"UpgradeRequired","","",58],[12,"PreconditionRequired","","",58],[12,"TooManyRequests","","",58],[12,"RequestHeaderFieldsTooLarge","","",58],[12,"UnavailableForLegalReasons","","",58],[12,"InternalServerError","","",58],[12,"NotImplemented","","",58],[12,"BadGateway","","",58],[12,"ServiceUnavailable","","",58],[12,"GatewayTimeout","","",58],[12,"HttpVersionNotSupported","","",58],[12,"VariantAlsoNegotiates","","",58],[12,"InsufficientStorage","","",58],[12,"LoopDetected","","",58],[12,"NotExtended","","",58],[12,"NetworkAuthenticationRequired","","",58],[12,"UnregisteredStatus","","",58],[0,"method","iron",""],[2,"Method","iron::method","HTTP methods, as defined in RFC 2616, §5.1.1."],[12,"Options","","",37],[12,"Get","","",37],[12,"Head","","",37],[12,"Post","","",37],[12,"Put","","",37],[12,"Delete","","",37],[12,"Trace","","",37],[12,"Connect","","",37],[12,"Patch","","",37],[12,"ExtensionMethod","","",37],[0,"headers","iron","Types and utilities for working with headers in HTTP requests and responses."],[2,"HeaderLineErr","iron::headers",""],[12,"EndOfFile","","",59],[12,"EndOfHeaders","","",59],[12,"MalformedHeaderValue","","",59],[12,"MalformedHeaderSyntax","","",59],[0,"test_utils","",""],[3,"from_stream_with_str","iron::headers::test_utils",""],[3,"to_stream_into_str","",""],[3,"assert_invalid","",""],[3,"assert_conversion_correct","",""],[3,"assert_interpretation_correct","",""],[0,"serialization_utils","iron::headers","Utility functions for assisting with conversion of headers from and to the HTTP text form."],[3,"normalise_header_name","iron::headers::serialization_utils","Normalise an HTTP header name."],[3,"comma_split","","Split a value on commas, as is common for HTTP headers."],[3,"comma_split_iter","",""],[6,"WriterUtil","",""],[9,"write_maybe_quoted_string","","",60],[9,"write_quoted_string","","",60],[9,"write_parameter","","",60],[9,"write_parameters","","",60],[9,"write_quality","","",60],[9,"write_token","","",60],[3,"comma_join","","Join a vector of values with commas, as is common for HTTP headers."],[3,"push_maybe_quoted_string","","Push a ( token | quoted-string ) onto a string and return it again"],[3,"maybe_quoted_string","","Make a string into a ( token | quoted-string ), preferring a token"],[3,"push_quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"unquote_string","","Parse a quoted-string. Returns ``None`` if the string is not a valid quoted-string."],[3,"maybe_unquote_string","","Parse a ( token | quoted-string ). Returns ``None`` if it is not valid."],[3,"push_parameter","",""],[3,"push_parameters","",""],[0,"accept_ranges","iron::headers","The Accept-Ranges request header, defined in RFC 2616, Section 14.5."],[2,"RangeUnit","iron::headers::accept_ranges",""],[12,"Bytes","","",38],[12,"OtherRangeUnit","","",38],[2,"AcceptableRanges","",""],[12,"RangeUnits","","",39],[12,"NoAcceptableRanges","","",39],[0,"connection","iron::headers","The Connection general header, defined in RFC 2616, Section 14.10."],[2,"Connection","iron::headers::connection","A value for the Connection header. Note that should it be a ``Token``, the string is in\nnormalised header case (e.g. \"Keep-Alive\")."],[12,"Token","","",40],[12,"Close","","",40],[0,"content_type","iron::headers","The Content-Type entity header, defined in RFC 2616, Section 14.17."],[1,"MediaType","iron::headers::content_type",""],[11,"type_","","",41],[11,"subtype","","",41],[11,"parameters","","",41],[0,"etag","iron::headers",""],[1,"EntityTag","iron::headers::etag",""],[11,"weak","","",42],[11,"opaque_tag","","",42],[3,"weak_etag","",""],[3,"strong_etag","",""],[0,"host","iron::headers","The Host request header, defined in RFC 2616, Section 14.23."],[1,"Host","iron::headers::host","A simple little thing for the host of a request"],[11,"name","","The name of the host that was requested",43],[11,"port","","If unspecified, assume the default port was used (80 for HTTP, 443 for HTTPS).\nIn that case, you shouldn't need to worry about it in URLs that you build, provided you\ninclude the scheme.",43],[0,"transfer_encoding","iron::headers","The Transfer-Encoding request header, defined in RFC 2616, sections 14.41 and 3.6."],[2,"TransferCoding","iron::headers::transfer_encoding","RFC 2616, section 3.6:"],[12,"Chunked","","",44],[12,"TransferExtension","","",44],[4,"DeltaSeconds","iron::headers",""],[2,"ConsumeCommaLWSResult","",""],[12,"CommaConsumed","","",45],[12,"EndOfValue","","",45],[12,"ErrCommaNotFound","","",45],[6,"HeaderEnum","",""],[9,"header_name","","",61],[9,"header_value","","",61],[9,"write_header","","",61],[9,"value_from_stream","","Return values:",61],[3,"header_enum_from_stream","","Shifted out of being a default method to fix an ICE (not yet reported, TODO)"],[1,"HeaderValueByteIterator","","An iterator over the bytes of a header value.\nThis ensures one cannot read past the end of a header mistakenly and that linear white space is\nhandled correctly so that nothing else needs to worry about it. Any linear whitespace (multiple\nspaces outside of a quoted-string) is compacted into a single SP."],[11,"reader","","",47],[11,"next_byte","","This field serves two purposes. *During* iteration, it will typically be ``None``, but\ncertain cases will cause it to be a ``Some``, meaning that the next ``next()`` call will\nreturn that value rather than reading a new byte. At the *end* of iteration (after\n``next()`` has returned ``None``), it will be the extra byte which it has had to consume\nfrom the stream because of the possibility of linear white space of the form ``CR LF SP``.\nIt is guaranteed that if ``self.state == Finished`` this will be a ``Some``.",47],[11,"at_start","","",47],[6,"HeaderConvertible","","A datatype for headers."],[9,"from_stream","","Read a header value from an iterator over the raw value.",62],[9,"to_stream","","Write the HTTP value of the header to the stream.",62],[9,"http_value","","The value of the header as it would be written for an HTTP header.",62],[6,"CommaListHeaderConvertible","","A header with multiple comma-separated values. Implement this and a HeaderConvertible\nimplementation for Vec<T> is yours for free—just make sure your reading does not consume the\ncomma."],[0,"request","",""],[2,"Header","iron::headers::request",""],[12,"CacheControl","","",52],[12,"Connection","","",52],[12,"Date","","",52],[12,"Pragma","","",52],[12,"Trailer","","",52],[12,"TransferEncoding","","",52],[12,"Upgrade","","",52],[12,"Via","","",52],[12,"Warning","","",52],[12,"Accept","","",52],[12,"AcceptCharset","","",52],[12,"AcceptEncoding","","",52],[12,"AcceptLanguage","","",52],[12,"Authorization","","",52],[12,"Expect","","",52],[12,"From","","",52],[12,"Host","","",52],[12,"IfMatch","","",52],[12,"IfModifiedSince","","",52],[12,"IfNoneMatch","","",52],[12,"IfRange","","",52],[12,"IfUnmodifiedSince","","",52],[12,"MaxForwards","","",52],[12,"ProxyAuthorization","","",52],[12,"Range","","",52],[12,"Referer","","",52],[12,"Te","","",52],[12,"UserAgent","","",52],[12,"Allow","","",52],[12,"ContentEncoding","","",52],[12,"ContentLanguage","","",52],[12,"ContentLength","","",52],[12,"ContentLocation","","",52],[12,"ContentMd5","","",52],[12,"ContentRange","","",52],[12,"ContentType","","",52],[12,"Expires","","",52],[12,"LastModified","","",52],[12,"ExtensionHeader","","",52],[1,"HeaderCollection","",""],[11,"cache_control","","",50],[11,"connection","","",50],[11,"date","","",50],[11,"pragma","","",50],[11,"trailer","","",50],[11,"transfer_encoding","","",50],[11,"upgrade","","",50],[11,"via","","",50],[11,"warning","","",50],[11,"accept","","",50],[11,"accept_charset","","",50],[11,"accept_encoding","","",50],[11,"accept_language","","",50],[11,"authorization","","",50],[11,"expect","","",50],[11,"from","","",50],[11,"host","","",50],[11,"if_match","","",50],[11,"if_modified_since","","",50],[11,"if_none_match","","",50],[11,"if_range","","",50],[11,"if_unmodified_since","","",50],[11,"max_forwards","","",50],[11,"proxy_authorization","","",50],[11,"range","","",50],[11,"referer","","",50],[11,"te","","",50],[11,"user_agent","","",50],[11,"allow","","",50],[11,"content_encoding","","",50],[11,"content_language","","",50],[11,"content_length","","",50],[11,"content_location","","",50],[11,"content_md5","","",50],[11,"content_range","","",50],[11,"content_type","","",50],[11,"expires","","",50],[11,"last_modified","","",50],[11,"extensions","","",50],[1,"HeaderCollectionIterator","",""],[0,"response","iron::headers",""],[2,"Header","iron::headers::response",""],[12,"CacheControl","","",55],[12,"Connection","","",55],[12,"Date","","",55],[12,"Pragma","","",55],[12,"Trailer","","",55],[12,"TransferEncoding","","",55],[12,"Upgrade","","",55],[12,"Via","","",55],[12,"Warning","","",55],[12,"AcceptPatch","","",55],[12,"AcceptRanges","","",55],[12,"Age","","",55],[12,"ETag","","",55],[12,"Location","","",55],[12,"ProxyAuthenticate","","",55],[12,"RetryAfter","","",55],[12,"Server","","",55],[12,"Vary","","",55],[12,"WwwAuthenticate","","",55],[12,"Allow","","",55],[12,"ContentEncoding","","",55],[12,"ContentLanguage","","",55],[12,"ContentLength","","",55],[12,"ContentLocation","","",55],[12,"ContentMd5","","",55],[12,"ContentRange","","",55],[12,"ContentType","","",55],[12,"Expires","","",55],[12,"LastModified","","",55],[12,"ExtensionHeader","","",55],[1,"HeaderCollection","",""],[11,"cache_control","","",53],[11,"connection","","",53],[11,"date","","",53],[11,"pragma","","",53],[11,"trailer","","",53],[11,"transfer_encoding","","",53],[11,"upgrade","","",53],[11,"via","","",53],[11,"warning","","",53],[11,"accept_patch","","",53],[11,"accept_ranges","","",53],[11,"age","","",53],[11,"etag","","",53],[11,"location","","",53],[11,"proxy_authenticate","","",53],[11,"retry_after","","",53],[11,"server","","",53],[11,"vary","","",53],[11,"www_authenticate","","",53],[11,"allow","","",53],[11,"content_encoding","","",53],[11,"content_language","","",53],[11,"content_length","","",53],[11,"content_location","","",53],[11,"content_md5","","",53],[11,"content_range","","",53],[11,"content_type","","",53],[11,"expires","","",53],[11,"last_modified","","",53],[11,"extensions","","",53],[1,"HeaderCollectionIterator","",""],[6,"Plugin","iron","An interface for plugins that cache values between calls."],[9,"get","","Return a copy of the plugin's produced value.",4],[9,"get_ref","","Return a reference to the plugin's produced value.",4],[9,"get_mut","","Return a mutable reference to the plugin's produced value.",4],[6,"Set","","A blanket trait providing the set and set_mut methods for all types."],[9,"set","","Modify self using the provided modifier.",3],[9,"set_mut","","Modify self through a mutable reference with the provided modifier.",3],[6,"Error","",""],[9,"name","","",63],[9,"description","","",63],[9,"cause","","",63],[6,"ErrorRefExt","",""],[9,"is","","",5],[9,"downcast","","",5]],"paths":[[1,"Request"],[1,"Url"],[1,"Iron"],[6,"Set"],[6,"Plugin"],[6,"ErrorRefExt"],[1,"TypeMap"],[1,"OccupiedEntry"],[1,"VacantEntry"],[6,"Modifier"],[6,"Handler"],[6,"BeforeMiddleware"],[6,"AfterMiddleware"],[6,"AroundMiddleware"],[6,"Chain"],[1,"ChainBuilder"],[1,"Box"],[1,"Arc"],[1,"FileError"],[1,"Response"],[6,"Bodyable"],[1,"ContentType"],[1,"Body"],[1,"String"],[1,"Vec"],[1,"File"],[1,"Path"],[1,"Status"],[1,"Redirect"],[1,"HttpResponse"],[1,"BufferedStream"],[1,"RequestWriter"],[1,"ResponseReader"],[2,"NetworkStream"],[1,"RequestBuffer"],[2,"RequestUri"],[1,"Request"],[2,"Method"],[2,"RangeUnit"],[2,"AcceptableRanges"],[2,"Connection"],[1,"MediaType"],[1,"EntityTag"],[1,"Host"],[2,"TransferCoding"],[2,"ConsumeCommaLWSResult"],[2,"HeaderValueByteIteratorState"],[1,"HeaderValueByteIterator"],[1,"Url"],[1,"Tm"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[2,"ContentCoding"],[2,"TransferCoding"],[2,"Status"],[2,"HeaderLineErr"],[6,"WriterUtil"],[6,"HeaderEnum"],[6,"HeaderConvertible"],[6,"Error"]]};

searchIndex['persistent'] = {"items":[[0,"","persistent","A set of middleware for sharing data between requests in the Iron\nframework."],[1,"State","","Middleware for data that persists between requests with read and write capabilities."],[1,"Read","","Middleware for data that persists between Requests with read-only capabilities."],[1,"Write","","Middleware for data that persists between Requests for data which mostly\nneeds to be written instead of read."],[10,"clone","","",0],[10,"clone","","",1],[10,"clone","","",2],[10,"eval","","",1],[10,"eval","","",0],[10,"eval","","",2],[10,"before","","",1],[10,"after","","",1],[10,"before","","",0],[10,"after","","",0],[10,"before","","",2],[10,"after","","",2],[10,"both","","Construct a new pair of `State` that can be passed directly to `Chain::link`.",1],[10,"one","","Construct a new `State` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",1],[10,"both","","Construct a new pair of `Read` that can be passed directly to `Chain::link`.",0],[10,"one","","Construct a new `Read` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",0],[10,"both","","Construct a new pair of `Write` that can be passed directly to `Chain::link`.",2],[10,"one","","Construct a new `Write` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",2]],"paths":[[1,"Read"],[1,"State"],[1,"Write"]]};

searchIndex['router'] = {"items":[[0,"","router","`Router` provides a fast router handler for the Iron web framework."],[1,"Router","","`Router` provides an interface for creating complex routes as middleware\nfor the Iron framework."],[10,"new","","`new` constructs a new, blank `Router`.",0],[10,"route","","Add a new route to a `Router`, matching both a method and glob pattern.",0],[10,"get","","Like route, but specialized to the `Get` method.",0],[10,"post","","Like route, but specialized to the `Post` method.",0],[10,"put","","Like route, but specialized to the `Put` method.",0],[10,"delete","","Like route, but specialized to the `Delete` method.",0],[10,"head","","Like route, but specialized to the `Head` method.",0],[10,"patch","","Like route, but specialized to the `Patch` method.",0],[10,"options","","Like route, but specialized to the `Options` method.",0],[10,"error","","Add a Handler to be used for this Router's `catch` method.",0],[10,"call","","",0],[10,"catch","","",0],[10,"new","route-recognizer","",1],[10,"insert","","",1],[10,"find","","",1],[10,"clone","route-recognizer::nfa","",2],[10,"clone_from","","",2],[10,"assert_receiver_is_total_eq","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"ne","","",2],[10,"new","","",2],[10,"insert","","",2],[10,"contains","","",2],[10,"clone","","",3],[10,"clone_from","","",3],[10,"assert_receiver_is_total_eq","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"ne","","",3],[10,"any","","",3],[10,"valid","","",3],[10,"invalid","","",3],[10,"valid_char","","",3],[10,"invalid_char","","",3],[10,"matches","","",3],[10,"clone","","",4],[10,"clone_from","","",4],[10,"new","","",4],[10,"start_capture","","",4],[10,"end_capture","","",4],[10,"extract","","",4],[10,"clone","","",5],[10,"clone_from","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"new","","",5],[10,"new","","",6],[10,"clone","","",7],[10,"clone_from","","",7],[10,"new","","",7],[10,"process","","",7],[10,"get","","",7],[10,"get_mut","","",7],[10,"put","","",7],[10,"put_state","","",7],[10,"acceptance","","",7],[10,"start_capture","","",7],[10,"end_capture","","",7],[10,"metadata","","",7],[10,"clone","route-recognizer","",8],[10,"clone_from","","",8],[10,"new","","",8],[10,"cmp","","",8],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"assert_receiver_is_total_eq","","",8],[10,"fmt","","",1],[10,"clone","","",1],[10,"clone_from","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"ne","","",1],[10,"index","","",1],[10,"new","","",9],[10,"clone","","",10],[10,"clone_from","","",10],[10,"new","","",10],[10,"add","","",10],[10,"recognize","","",10],[1,"Params","router",""]],"paths":[[1,"Router"],[1,"Params"],[1,"CharSet"],[2,"CharacterClass"],[1,"Thread"],[1,"State"],[1,"Match"],[1,"NFA"],[1,"Metadata"],[1,"Match"],[1,"Router"]]};

searchIndex['urlencoded'] = {"items":[[0,"","urlencoded","URL Encoded Plugin for Iron."],[1,"UrlEncodedQuery","","Plugin for `Request` that extracts URL encoded data from the URL query string."],[1,"UrlEncodedBody","","Plugin for `Request` that extracts URL encoded data from the request body."],[4,"QueryMap","","Hashmap mapping strings to vectors of strings."],[10,"eval","","",0],[10,"eval","","",1]],"paths":[[1,"UrlEncodedQuery"],[1,"UrlEncodedBody"]]};

searchIndex['bodyparser'] = {"items":[[0,"","bodyparser","Body Parser Plugin for Iron"],[1,"BodyParser","",""],[10,"clone","","",0],[10,"eval","","",0]],"paths":[[1,"BodyParser"]]};

initSearch(searchIndex);

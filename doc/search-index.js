var searchIndex = {};
searchIndex['iron'] = {"items":[[0,"","iron","The main crate for the Iron library."],[1,"Request","","The `Request` given to all `Middleware`."],[11,"url","","The requested URL.",0],[11,"remote_addr","","The originating address of the request.",0],[11,"headers","","The request headers.",0],[11,"body","","The request body.",0],[11,"method","","The request method.",0],[11,"extensions","","Extensible storage for data passed between middleware.",0],[1,"Url","","HTTP/HTTPS URL type for Iron."],[11,"scheme","","The lower-cased scheme of the URL, typically \"http\" or \"https\".",1],[11,"host","","The host field of the URL, probably a domain.",1],[11,"port","","The connection port.",1],[11,"path","","The URL path, the resource to be accessed.",1],[11,"username","","The URL username field, from the userinfo section of the URL.",1],[11,"password","","The URL password field, from the userinfo section of the URL.",1],[11,"query","","The URL query string.",1],[11,"fragment","","The URL fragment.",1],[1,"Response","","The response representation given to `Middleware`"],[11,"body","","The body of the response.",2],[11,"headers","","The headers of the response.",2],[11,"status","","The response status-code.",2],[11,"extensions","","A TypeMap to be used as an extensible storage for data\nassociated with this Response.",2],[1,"Iron","","The primary entrance point to `Iron`, a `struct` to instantiate a new server."],[11,"handler","","Iron contains a `Handler`, which it uses to create responses for client\nrequests.",3],[0,"typemap","","Re-exports from the TypeMap crate."],[10,"new","typemap","Create a new, empty TypeMap.",4],[10,"insert","","Insert a value into the map with a specified key type.",4],[10,"find","","Find a value in the map and get a reference to it.",4],[10,"find_mut","","Find a value in the map and get a mutable reference to it.",4],[10,"contains","","Check if a key has an associated value stored in the map.",4],[10,"remove","","Remove a value from the map.",4],[10,"data","","Read the underlying HashMap",4],[10,"data_mut","","Get a mutable reference to the underlying HashMap",4],[10,"len","","",4],[10,"is_empty","","",4],[10,"clear","","",4],[1,"TypeMap","iron::typemap","A map keyed by types."],[6,"Assoc","","This trait defines the relationship between keys and values in a TypeMap."],[0,"middleware","iron","Iron's Middleware and Handler System"],[1,"ChainBuilder","iron::middleware","The default Chain used in Iron."],[6,"Handler","","`Handler`s are responsible for handling requests by creating Responses from Requests."],[9,"call","","Produce a `Response` from a Request, with the possibility of error.",5],[10,"catch","","If `Handler`'s call method produces an Err, then this method is called\nto produce a `Response` and possibly handle the error.",5],[6,"BeforeMiddleware","","`BeforeMiddleware` are fired before a `Handler` is called inside of a Chain."],[9,"before","","Do whatever work this middleware should do with a `Request` object.",6],[10,"catch","","Try to `catch` an error thrown by this Middleware or a previous `BeforeMiddleware`.",6],[6,"AfterMiddleware","","`AfterMiddleware` are fired after a `Handler` is called inside of a Chain."],[9,"after","","Do whatever work this middleware needs to do with both a `Request` and `Response` objects.",7],[10,"catch","","Try to catch an error thrown by previous `AfterMiddleware`, the `Handler`, or a previous\n`BeforeMiddleware`.",7],[6,"AroundMiddleware","","AroundMiddleware are used to wrap and replace the `Handler` in a `Chain`."],[9,"around","","Produce a `Handler` from this `AroundMiddleware` given another `Handler`.",8],[6,"Chain","","Chain's hold `BeforeMiddleware`, a `Handler`, and `AfterMiddleware` and are responsible\nfor correctly dispatching a `Request` through them."],[9,"new","","Create a new Chain from a `Handler`.",9],[9,"link","","Link both a before and after middleware to the chain at once.",9],[9,"link_before","","Link a `BeforeMiddleware` to the Chain.",9],[9,"link_after","","Link a `AfterMiddleware` to the Chain.",9],[9,"around","","Wrap the Chain's `Handler` using an AroundMiddleware.",9],[10,"new","","Construct a new ChainBuilder from a `Handler`.",10],[10,"new","","",10],[10,"link","","",10],[10,"link_before","","",10],[10,"link_after","","",10],[10,"around","","",10],[10,"call","","",10],[10,"catch","","",10],[10,"call","alloc::boxed","",11],[10,"catch","","",11],[10,"call","alloc::arc","",12],[10,"catch","","",12],[0,"errors","iron","Some common error types for use within Iron and in downstream middleware."],[1,"FileError","iron::errors","The standard Error implementation used to wrap IoErrors\nthat occur when reading or writing files or otherwise\ninteracting with the file system."],[10,"eq","","",13],[10,"ne","","",13],[10,"clone","","",13],[10,"fmt","","",13],[10,"new","","Create a new FileError from an IoError.",13],[10,"unwrap","","Access the original IoError.",13],[10,"name","","",13],[10,"description","","",13],[10,"clone","iron","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"parse","","Create a URL from a string.",1],[10,"from_generic_url","","Create a `Url` from a `rust-url` `Url`.",1],[10,"into_generic_url","","Create a `rust-url` `Url` from a `Url`.",1],[10,"fmt","","",1],[10,"encode","","",1],[10,"decode","","",1],[10,"fmt","","",0],[10,"from_http","","Create a request from an HttpRequest.",0],[10,"extensions","","",0],[10,"extensions_mut","","",0],[10,"load","http::server::request","Get a response from an open socket.",14],[10,"new","http::buffer","",15],[10,"poke_byte","","Poke a single byte back so it will be read next. For this to make sense, you must have just\nread that byte. If `self.pos` is 0 and `self.max` is not 0 (i.e. if the buffer is just\nfilled\nVery great caution must be used in calling this as it will fail if `self.pos` is 0.",15],[10,"read_byte","","Slightly faster implementation of read_byte than that which is provided by ReaderUtil\n(which just uses `read()`)",15],[10,"finish_response","","Finish off writing a response: this flushes the writer and in case of chunked\nTransfer-Encoding writes the ending zero-length chunk to indicate completion.",15],[10,"read","","Read at most N bytes into `buf`, where N is the minimum of `buf.len()` and the buffer size.",15],[10,"read_at_least","","",15],[10,"read_byte","","",15],[10,"push","","",15],[10,"push_at_least","","",15],[10,"read_exact","","",15],[10,"read_to_end","","",15],[10,"read_to_string","","",15],[10,"bytes","","",15],[10,"read_le_uint_n","","",15],[10,"read_le_int_n","","",15],[10,"read_be_uint_n","","",15],[10,"read_be_int_n","","",15],[10,"read_le_uint","","",15],[10,"read_le_int","","",15],[10,"read_be_uint","","",15],[10,"read_be_int","","",15],[10,"read_be_u64","","",15],[10,"read_be_u32","","",15],[10,"read_be_u16","","",15],[10,"read_be_i64","","",15],[10,"read_be_i32","","",15],[10,"read_be_i16","","",15],[10,"read_be_f64","","",15],[10,"read_be_f32","","",15],[10,"read_le_u64","","",15],[10,"read_le_u32","","",15],[10,"read_le_u16","","",15],[10,"read_le_i64","","",15],[10,"read_le_i32","","",15],[10,"read_le_i16","","",15],[10,"read_le_f64","","",15],[10,"read_le_f32","","",15],[10,"read_u8","","",15],[10,"read_i8","","",15],[10,"by_ref","","",15],[10,"write","","",15],[10,"flush","","",15],[10,"flush","","",15],[10,"write_fmt","","",15],[10,"write_str","","",15],[10,"write_line","","",15],[10,"write_char","","",15],[10,"write_int","","",15],[10,"write_uint","","",15],[10,"write_le_uint","","",15],[10,"write_le_int","","",15],[10,"write_be_uint","","",15],[10,"write_be_int","","",15],[10,"write_be_u64","","",15],[10,"write_be_u32","","",15],[10,"write_be_u16","","",15],[10,"write_be_i64","","",15],[10,"write_be_i32","","",15],[10,"write_be_i16","","",15],[10,"write_be_f64","","",15],[10,"write_be_f32","","",15],[10,"write_le_u64","","",15],[10,"write_le_u32","","",15],[10,"write_le_u16","","",15],[10,"write_le_i64","","",15],[10,"write_le_i32","","",15],[10,"write_le_i16","","",15],[10,"write_le_f64","","",15],[10,"write_le_f32","","",15],[10,"write_u8","","",15],[10,"write_i8","","",15],[10,"by_ref","","",15],[10,"new","http::client::request","Create a `RequestWriter` writing to the specified location",16],[10,"new_request","","",16],[10,"try_connect","","Connect to the remote host if not already connected.",16],[10,"connect","","Connect to the remote host; fails if already connected.\nReturns ``true`` upon success and ``false`` upon failure (also use conditions).",16],[10,"try_write_headers","","Write the Request-Line and headers of the response, if we have not already done so.",16],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",16],[10,"read_response","","Send the request and construct a `ResponseReader` out of it.",16],[10,"write","","",16],[10,"flush","","",16],[10,"flush","","",16],[10,"write_fmt","","",16],[10,"write_str","","",16],[10,"write_line","","",16],[10,"write_char","","",16],[10,"write_int","","",16],[10,"write_uint","","",16],[10,"write_le_uint","","",16],[10,"write_le_int","","",16],[10,"write_be_uint","","",16],[10,"write_be_int","","",16],[10,"write_be_u64","","",16],[10,"write_be_u32","","",16],[10,"write_be_u16","","",16],[10,"write_be_i64","","",16],[10,"write_be_i32","","",16],[10,"write_be_i16","","",16],[10,"write_be_f64","","",16],[10,"write_be_f32","","",16],[10,"write_le_u64","","",16],[10,"write_le_u32","","",16],[10,"write_le_u16","","",16],[10,"write_le_i64","","",16],[10,"write_le_i32","","",16],[10,"write_le_i16","","",16],[10,"write_le_f64","","",16],[10,"write_le_f32","","",16],[10,"write_u8","","",16],[10,"write_i8","","",16],[10,"by_ref","","",16],[10,"construct","http::client::response","",17],[10,"read","","",17],[10,"read_at_least","","",17],[10,"read_byte","","",17],[10,"push","","",17],[10,"push_at_least","","",17],[10,"read_exact","","",17],[10,"read_to_end","","",17],[10,"read_to_string","","",17],[10,"bytes","","",17],[10,"read_le_uint_n","","",17],[10,"read_le_int_n","","",17],[10,"read_be_uint_n","","",17],[10,"read_be_int_n","","",17],[10,"read_le_uint","","",17],[10,"read_le_int","","",17],[10,"read_be_uint","","",17],[10,"read_be_int","","",17],[10,"read_be_u64","","",17],[10,"read_be_u32","","",17],[10,"read_be_u16","","",17],[10,"read_be_i64","","",17],[10,"read_be_i32","","",17],[10,"read_be_i16","","",17],[10,"read_be_f64","","",17],[10,"read_be_f32","","",17],[10,"read_le_u64","","",17],[10,"read_le_u32","","",17],[10,"read_le_u16","","",17],[10,"read_le_i64","","",17],[10,"read_le_i32","","",17],[10,"read_le_i16","","",17],[10,"read_le_f64","","",17],[10,"read_le_f32","","",17],[10,"read_u8","","",17],[10,"read_i8","","",17],[10,"by_ref","","",17],[10,"connect","http::client::sslclients::openssl","",18],[10,"read","","",18],[10,"read_at_least","","",18],[10,"read_byte","","",18],[10,"push","","",18],[10,"push_at_least","","",18],[10,"read_exact","","",18],[10,"read_to_end","","",18],[10,"read_to_string","","",18],[10,"bytes","","",18],[10,"read_le_uint_n","","",18],[10,"read_le_int_n","","",18],[10,"read_be_uint_n","","",18],[10,"read_be_int_n","","",18],[10,"read_le_uint","","",18],[10,"read_le_int","","",18],[10,"read_be_uint","","",18],[10,"read_be_int","","",18],[10,"read_be_u64","","",18],[10,"read_be_u32","","",18],[10,"read_be_u16","","",18],[10,"read_be_i64","","",18],[10,"read_be_i32","","",18],[10,"read_be_i16","","",18],[10,"read_be_f64","","",18],[10,"read_be_f32","","",18],[10,"read_le_u64","","",18],[10,"read_le_u32","","",18],[10,"read_le_u16","","",18],[10,"read_le_i64","","",18],[10,"read_le_i32","","",18],[10,"read_le_i16","","",18],[10,"read_le_f64","","",18],[10,"read_le_f32","","",18],[10,"read_u8","","",18],[10,"read_i8","","",18],[10,"by_ref","","",18],[10,"write","","",18],[10,"flush","","",18],[10,"flush","","",18],[10,"write_fmt","","",18],[10,"write_str","","",18],[10,"write_line","","",18],[10,"write_char","","",18],[10,"write_int","","",18],[10,"write_uint","","",18],[10,"write_le_uint","","",18],[10,"write_le_int","","",18],[10,"write_be_uint","","",18],[10,"write_be_int","","",18],[10,"write_be_u64","","",18],[10,"write_be_u32","","",18],[10,"write_be_u16","","",18],[10,"write_be_i64","","",18],[10,"write_be_i32","","",18],[10,"write_be_i16","","",18],[10,"write_be_f64","","",18],[10,"write_be_f32","","",18],[10,"write_le_u64","","",18],[10,"write_le_u32","","",18],[10,"write_le_u16","","",18],[10,"write_le_i64","","",18],[10,"write_le_i32","","",18],[10,"write_le_i16","","",18],[10,"write_le_f64","","",18],[10,"write_le_f32","","",18],[10,"write_u8","","",18],[10,"write_i8","","",18],[10,"by_ref","","",18],[10,"new","http::server::request","",19],[10,"read_request_line","","",19],[10,"read_header","","Read a header (name, value) pair.",19],[10,"read","","",19],[10,"read_at_least","","",19],[10,"read_byte","","",19],[10,"push","","",19],[10,"push_at_least","","",19],[10,"read_exact","","",19],[10,"read_to_end","","",19],[10,"read_to_string","","",19],[10,"bytes","","",19],[10,"read_le_uint_n","","",19],[10,"read_le_int_n","","",19],[10,"read_be_uint_n","","",19],[10,"read_be_int_n","","",19],[10,"read_le_uint","","",19],[10,"read_le_int","","",19],[10,"read_be_uint","","",19],[10,"read_be_int","","",19],[10,"read_be_u64","","",19],[10,"read_be_u32","","",19],[10,"read_be_u16","","",19],[10,"read_be_i64","","",19],[10,"read_be_i32","","",19],[10,"read_be_i16","","",19],[10,"read_be_f64","","",19],[10,"read_be_f32","","",19],[10,"read_le_u64","","",19],[10,"read_le_u32","","",19],[10,"read_le_u16","","",19],[10,"read_le_i64","","",19],[10,"read_le_i32","","",19],[10,"read_le_i16","","",19],[10,"read_le_f64","","",19],[10,"read_le_f32","","",19],[10,"read_u8","","",19],[10,"read_i8","","",19],[10,"by_ref","","",19],[10,"assert_receiver_is_total_eq","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"ne","","",20],[10,"fmt","","",20],[10,"new","http::server::response","Create a `ResponseWriter` writing to the specified location",21],[10,"write_content_auto","","Write a response with the specified Content-Type and content; the Content-Length header is\nset based upon the contents",21],[10,"try_write_headers","","Write the Status-Line and headers of the response, if we have not already done so.",21],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",21],[10,"finish_response","","",21],[10,"write","","",21],[10,"flush","","",21],[10,"flush","","",21],[10,"write_fmt","","",21],[10,"write_str","","",21],[10,"write_line","","",21],[10,"write_char","","",21],[10,"write_int","","",21],[10,"write_uint","","",21],[10,"write_le_uint","","",21],[10,"write_le_int","","",21],[10,"write_be_uint","","",21],[10,"write_be_int","","",21],[10,"write_be_u64","","",21],[10,"write_be_u32","","",21],[10,"write_be_u16","","",21],[10,"write_be_i64","","",21],[10,"write_be_i32","","",21],[10,"write_be_i16","","",21],[10,"write_be_f64","","",21],[10,"write_be_f32","","",21],[10,"write_le_u64","","",21],[10,"write_le_u32","","",21],[10,"write_le_u16","","",21],[10,"write_le_i64","","",21],[10,"write_le_i32","","",21],[10,"write_le_i16","","",21],[10,"write_le_f64","","",21],[10,"write_le_f32","","",21],[10,"write_u8","","",21],[10,"write_i8","","",21],[10,"by_ref","","",21],[10,"hash","http::method","",22],[10,"clone","","",22],[10,"clone_from","","",22],[10,"assert_receiver_is_total_eq","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"ne","","",22],[10,"from_str","","Get a *known* `Method` from an *ASCII* string, regardless of case.",22],[10,"fmt","","",22],[10,"from_str_or_new","","Get a `Method` from an *ASCII* string.",22],[10,"assert_receiver_is_total_eq","http::headers::accept_ranges","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"ne","","",23],[10,"clone","","",23],[10,"clone_from","","",23],[10,"assert_receiver_is_total_eq","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"ne","","",24],[10,"clone","","",24],[10,"clone_from","","",24],[10,"from_stream","","",24],[10,"to_stream","","",24],[10,"http_value","","",24],[10,"to_stream","","",24],[10,"assert_receiver_is_total_eq","http::headers::connection","",25],[10,"eq","","",25],[10,"ne","","",25],[10,"ne","","",25],[10,"clone","","",25],[10,"clone_from","","",25],[10,"fmt","","",25],[10,"from_stream","","",25],[10,"to_stream","","",25],[10,"http_value","","",25],[10,"to_stream","","",25],[10,"assert_receiver_is_total_eq","http::headers::content_type","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"clone_from","","",26],[10,"new","","",26],[10,"fmt","","",26],[10,"from_stream","","",26],[10,"to_stream","","",26],[10,"http_value","","",26],[10,"to_stream","","",26],[10,"assert_receiver_is_total_eq","http::headers::etag","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"clone_from","","",27],[10,"fmt","","",27],[10,"from_stream","","",27],[10,"to_stream","","",27],[10,"http_value","","",27],[10,"to_stream","","",27],[10,"assert_receiver_is_total_eq","http::headers::host","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"ne","","",28],[10,"clone","","",28],[10,"clone_from","","",28],[10,"fmt","","",28],[10,"from_stream","","",28],[10,"http_value","","",28],[10,"to_stream","","",28],[10,"assert_receiver_is_total_eq","http::headers::transfer_encoding","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"ne","","",29],[10,"clone","","",29],[10,"clone_from","","",29],[10,"from_stream","","",29],[10,"to_stream","","",29],[10,"http_value","","",29],[10,"to_stream","","",29],[10,"assert_receiver_is_total_eq","http::headers","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"ne","","",30],[10,"clone","","",30],[10,"clone_from","","",30],[10,"assert_receiver_is_total_eq","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"ne","","",31],[10,"new","","",32],[10,"verify_consumed","","Check that the entire header value has been consumed.",32],[10,"some_if_consumed","","Turn a constructed header value into an Option: Some(value) if the header value is consumed\nor None if it is not, thus indicating: \"I'm finished and expect nothing more. Anything more\nis an error.\"",32],[10,"consume_optional_lws","","Consume optional `*LWS`. That is, zero or more of SP and HT, until it\ngets to something other than SP and HT or gets to the end of the header.",32],[10,"consume_lws","","Consume `1*LWS`. That is, one or more of SP and HT, until it gets to\nsomething other than SP and HT or gets to the end of the header.",32],[10,"consume_comma_lws","","Return values:\n- CommaConsumed if there was a comma and it was consumed;\n- EndOfValue if the header value has been completely consumed;\n- ErrCommaNotFound if the next thing wasn't a comma (this is an error state)",32],[10,"read_quoted_string","","Read a quoted-string from the current position.\nIf the quoted-string is not begun immediately or the header ends before it is completed,\nthen None is returned; TODO: decide if I can return the bytes read (at present, escapes and\ndouble quote would be lost if I did that).",32],[10,"read_token_or_quoted_string","","Read a token (RFC 2616 definition) from the header value.",32],[10,"read_token","","Read a token (RFC 2616 definition) from the header value.",32],[10,"next","","",32],[10,"size_hint","","",32],[10,"chain","","",32],[10,"zip","","",32],[10,"map","","",32],[10,"filter","","",32],[10,"filter_map","","",32],[10,"enumerate","","",32],[10,"peekable","","",32],[10,"skip_while","","",32],[10,"take_while","","",32],[10,"skip","","",32],[10,"take","","",32],[10,"scan","","",32],[10,"flat_map","","",32],[10,"fuse","","",32],[10,"inspect","","",32],[10,"by_ref","","",32],[10,"collect","","",32],[10,"nth","","",32],[10,"last","","",32],[10,"fold","","",32],[10,"count","","",32],[10,"all","","",32],[10,"any","","",32],[10,"find","","",32],[10,"position","","",32],[10,"max_by","","",32],[10,"min_by","","",32],[10,"from_stream","collections::vec","",33],[10,"to_stream","","",33],[10,"http_value","","",33],[10,"to_stream","","",33],[10,"from_stream","collections::string","",34],[10,"to_stream","","",34],[10,"http_value","","",34],[10,"to_stream","","",34],[10,"from_stream","url","",35],[10,"http_value","","",35],[10,"to_stream","","",35],[10,"from_stream","http::method","",22],[10,"http_value","","",22],[10,"to_stream","","",22],[10,"from_stream","time","",36],[10,"http_value","","",36],[10,"to_stream","","",36],[10,"clone","http::headers::request","",37],[10,"clone_from","","",37],[10,"new","","",37],[10,"insert","","Consume a header, putting it into this structure.",37],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",37],[10,"iter","","",37],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",37],[10,"next","","",38],[10,"size_hint","","",38],[10,"chain","","",38],[10,"zip","","",38],[10,"map","","",38],[10,"filter","","",38],[10,"filter_map","","",38],[10,"enumerate","","",38],[10,"peekable","","",38],[10,"skip_while","","",38],[10,"take_while","","",38],[10,"skip","","",38],[10,"take","","",38],[10,"scan","","",38],[10,"flat_map","","",38],[10,"fuse","","",38],[10,"inspect","","",38],[10,"by_ref","","",38],[10,"collect","","",38],[10,"nth","","",38],[10,"last","","",38],[10,"fold","","",38],[10,"count","","",38],[10,"all","","",38],[10,"any","","",38],[10,"find","","",38],[10,"position","","",38],[10,"max_by","","",38],[10,"min_by","","",38],[10,"header_name","","",39],[10,"header_value","","",39],[10,"write_header","","",39],[10,"value_from_stream","","",39],[10,"clone","http::headers::response","",40],[10,"clone_from","","",40],[10,"new","","",40],[10,"insert","","Consume a header, putting it into this structure.",40],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",40],[10,"iter","","",40],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",40],[10,"next","","",41],[10,"size_hint","","",41],[10,"chain","","",41],[10,"zip","","",41],[10,"map","","",41],[10,"filter","","",41],[10,"filter_map","","",41],[10,"enumerate","","",41],[10,"peekable","","",41],[10,"skip_while","","",41],[10,"take_while","","",41],[10,"skip","","",41],[10,"take","","",41],[10,"scan","","",41],[10,"flat_map","","",41],[10,"fuse","","",41],[10,"inspect","","",41],[10,"by_ref","","",41],[10,"collect","","",41],[10,"nth","","",41],[10,"last","","",41],[10,"fold","","",41],[10,"count","","",41],[10,"all","","",41],[10,"any","","",41],[10,"find","","",41],[10,"position","","",41],[10,"max_by","","",41],[10,"min_by","","",41],[10,"header_name","","",42],[10,"header_value","","",42],[10,"write_header","","",42],[10,"value_from_stream","","",42],[10,"fmt","http::rfc2616::content_coding","",43],[10,"from_str","","",43],[10,"fmt","http::rfc2616::transfer_coding","",44],[10,"clone","http::status","",45],[10,"clone_from","","",45],[10,"eq","","",45],[10,"ne","","",45],[10,"ne","","",45],[10,"assert_receiver_is_total_eq","","",45],[10,"code","","Get the status code",45],[10,"reason","","Get the reason phrase",45],[10,"from_code_and_reason","","Get a status from the code and reason",45],[10,"fmt","","",45],[10,"fmt","","",45],[10,"to_i64","","Equivalent to `Some(self.code() as i64)`",45],[10,"to_u64","","Equivalent to `Some(self.code() as u64)`",45],[10,"to_int","","",45],[10,"to_i8","","",45],[10,"to_i16","","",45],[10,"to_i32","","",45],[10,"to_uint","","",45],[10,"to_u8","","",45],[10,"to_u16","","",45],[10,"to_u32","","",45],[10,"to_f32","","",45],[10,"to_f64","","",45],[10,"from_i64","","Get a *registered* status code from the number of its status code.",45],[10,"from_u64","","Get a *registered* status code from the number of its status code.",45],[10,"from_int","","",45],[10,"from_i8","","",45],[10,"from_i16","","",45],[10,"from_i32","","",45],[10,"from_uint","","",45],[10,"from_u8","","",45],[10,"from_u16","","",45],[10,"from_u32","","",45],[10,"from_f32","","",45],[10,"from_f64","","",45],[10,"new","iron","Construct a blank Response",2],[10,"status","","Create a new response with the status.",2],[10,"with","","Create a new response with the specified body and status.",2],[10,"redirect","","Create a new Response with the `location` header set to the specified url.",2],[10,"from_file","","Create a response from a file on disk.",2],[10,"fmt","","",2],[10,"extensions","","",2],[10,"extensions_mut","","",2],[10,"listen","","Kick off the server process.",3],[10,"new","","Instantiate a new instance of `Iron`.",3],[4,"IronError","",""],[4,"IronResult","",""],[1,"TypeMap","","A map keyed by types."],[0,"status","",""],[2,"Status","iron::status","HTTP status code"],[12,"Continue","","",45],[12,"SwitchingProtocols","","",45],[12,"Processing","","",45],[12,"Ok","","",45],[12,"Created","","",45],[12,"Accepted","","",45],[12,"NonAuthoritativeInformation","","",45],[12,"NoContent","","",45],[12,"ResetContent","","",45],[12,"PartialContent","","",45],[12,"MultiStatus","","",45],[12,"AlreadyReported","","",45],[12,"ImUsed","","",45],[12,"MultipleChoices","","",45],[12,"MovedPermanently","","",45],[12,"Found","","",45],[12,"SeeOther","","",45],[12,"NotModified","","",45],[12,"UseProxy","","",45],[12,"SwitchProxy","","",45],[12,"TemporaryRedirect","","",45],[12,"PermanentRedirect","","",45],[12,"BadRequest","","",45],[12,"Unauthorized","","",45],[12,"PaymentRequired","","",45],[12,"Forbidden","","",45],[12,"NotFound","","",45],[12,"MethodNotAllowed","","",45],[12,"NotAcceptable","","",45],[12,"ProxyAuthenticationRequired","","",45],[12,"RequestTimeout","","",45],[12,"Conflict","","",45],[12,"Gone","","",45],[12,"LengthRequired","","",45],[12,"PreconditionFailed","","",45],[12,"RequestEntityTooLarge","","",45],[12,"RequestUriTooLong","","",45],[12,"UnsupportedMediaType","","",45],[12,"RequestedRangeNotSatisfiable","","",45],[12,"ExpectationFailed","","",45],[12,"ImATeapot","","",45],[12,"AuthenticationTimeout","","",45],[12,"UnprocessableEntity","","",45],[12,"Locked","","",45],[12,"FailedDependency","","",45],[12,"MethodFailure","","",45],[12,"UnorderedCollection","","",45],[12,"UpgradeRequired","","",45],[12,"PreconditionRequired","","",45],[12,"TooManyRequests","","",45],[12,"RequestHeaderFieldsTooLarge","","",45],[12,"UnavailableForLegalReasons","","",45],[12,"InternalServerError","","",45],[12,"NotImplemented","","",45],[12,"BadGateway","","",45],[12,"ServiceUnavailable","","",45],[12,"GatewayTimeout","","",45],[12,"HttpVersionNotSupported","","",45],[12,"VariantAlsoNegotiates","","",45],[12,"InsufficientStorage","","",45],[12,"LoopDetected","","",45],[12,"NotExtended","","",45],[12,"NetworkAuthenticationRequired","","",45],[12,"UnregisteredStatus","","",45],[0,"method","iron",""],[2,"Method","iron::method","HTTP methods, as defined in RFC 2616, §5.1.1."],[12,"Options","","",22],[12,"Get","","",22],[12,"Head","","",22],[12,"Post","","",22],[12,"Put","","",22],[12,"Delete","","",22],[12,"Trace","","",22],[12,"Connect","","",22],[12,"Patch","","",22],[12,"ExtensionMethod","","",22],[0,"headers","iron","Types and utilities for working with headers in HTTP requests and responses."],[2,"HeaderLineErr","iron::headers",""],[12,"EndOfFile","","",46],[12,"EndOfHeaders","","",46],[12,"MalformedHeaderValue","","",46],[12,"MalformedHeaderSyntax","","",46],[0,"test_utils","",""],[3,"from_stream_with_str","iron::headers::test_utils",""],[3,"to_stream_into_str","",""],[3,"assert_invalid","",""],[3,"assert_conversion_correct","",""],[3,"assert_interpretation_correct","",""],[0,"serialization_utils","iron::headers","Utility functions for assisting with conversion of headers from and to the HTTP text form."],[3,"normalise_header_name","iron::headers::serialization_utils","Normalise an HTTP header name."],[3,"comma_split","","Split a value on commas, as is common for HTTP headers."],[3,"comma_split_iter","",""],[6,"WriterUtil","",""],[9,"write_maybe_quoted_string","","",47],[9,"write_quoted_string","","",47],[9,"write_parameter","","",47],[9,"write_parameters","","",47],[9,"write_quality","","",47],[9,"write_token","","",47],[3,"comma_join","","Join a vector of values with commas, as is common for HTTP headers."],[3,"push_maybe_quoted_string","","Push a ( token | quoted-string ) onto a string and return it again"],[3,"maybe_quoted_string","","Make a string into a ( token | quoted-string ), preferring a token"],[3,"push_quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"unquote_string","","Parse a quoted-string. Returns ``None`` if the string is not a valid quoted-string."],[3,"maybe_unquote_string","","Parse a ( token | quoted-string ). Returns ``None`` if it is not valid."],[3,"push_parameter","",""],[3,"push_parameters","",""],[0,"accept_ranges","iron::headers","The Accept-Ranges request header, defined in RFC 2616, Section 14.5."],[2,"RangeUnit","iron::headers::accept_ranges",""],[12,"Bytes","","",23],[12,"OtherRangeUnit","","",23],[2,"AcceptableRanges","",""],[12,"RangeUnits","","",24],[12,"NoAcceptableRanges","","",24],[0,"connection","iron::headers","The Connection general header, defined in RFC 2616, Section 14.10."],[2,"Connection","iron::headers::connection","A value for the Connection header. Note that should it be a ``Token``, the string is in\nnormalised header case (e.g. \"Keep-Alive\")."],[12,"Token","","",25],[12,"Close","","",25],[0,"content_type","iron::headers","The Content-Type entity header, defined in RFC 2616, Section 14.17."],[1,"MediaType","iron::headers::content_type",""],[11,"type_","","",26],[11,"subtype","","",26],[11,"parameters","","",26],[0,"etag","iron::headers",""],[1,"EntityTag","iron::headers::etag",""],[11,"weak","","",27],[11,"opaque_tag","","",27],[3,"weak_etag","",""],[3,"strong_etag","",""],[0,"host","iron::headers","The Host request header, defined in RFC 2616, Section 14.23."],[1,"Host","iron::headers::host","A simple little thing for the host of a request"],[11,"name","","The name of the host that was requested",28],[11,"port","","If unspecified, assume the default port was used (80 for HTTP, 443 for HTTPS).\nIn that case, you shouldn't need to worry about it in URLs that you build, provided you\ninclude the scheme.",28],[0,"transfer_encoding","iron::headers","The Transfer-Encoding request header, defined in RFC 2616, sections 14.41 and 3.6."],[2,"TransferCoding","iron::headers::transfer_encoding","RFC 2616, section 3.6:"],[12,"Chunked","","",29],[12,"TransferExtension","","",29],[4,"DeltaSeconds","iron::headers",""],[2,"ConsumeCommaLWSResult","",""],[12,"CommaConsumed","","",30],[12,"EndOfValue","","",30],[12,"ErrCommaNotFound","","",30],[6,"HeaderEnum","",""],[9,"header_name","","",48],[9,"header_value","","",48],[9,"write_header","","",48],[9,"value_from_stream","","Return values:",48],[3,"header_enum_from_stream","","Shifted out of being a default method to fix an ICE (not yet reported, TODO)"],[1,"HeaderValueByteIterator","","An iterator over the bytes of a header value.\nThis ensures one cannot read past the end of a header mistakenly and that linear white space is\nhandled correctly so that nothing else needs to worry about it. Any linear whitespace (multiple\nspaces outside of a quoted-string) is compacted into a single SP."],[11,"reader","","",32],[11,"next_byte","","This field serves two purposes. *During* iteration, it will typically be ``None``, but\ncertain cases will cause it to be a ``Some``, meaning that the next ``next()`` call will\nreturn that value rather than reading a new byte. At the *end* of iteration (after\n``next()`` has returned ``None``), it will be the extra byte which it has had to consume\nfrom the stream because of the possibility of linear white space of the form ``CR LF SP``.\nIt is guaranteed that if ``self.state == Finished`` this will be a ``Some``.",32],[11,"at_start","","",32],[6,"HeaderConvertible","","A datatype for headers."],[9,"from_stream","","Read a header value from an iterator over the raw value.",49],[9,"to_stream","","Write the HTTP value of the header to the stream.",49],[9,"http_value","","The value of the header as it would be written for an HTTP header.",49],[6,"CommaListHeaderConvertible","","A header with multiple comma-separated values. Implement this and a HeaderConvertible\nimplementation for Vec<T> is yours for free—just make sure your reading does not consume the\ncomma."],[0,"request","",""],[2,"Header","iron::headers::request",""],[12,"CacheControl","","",39],[12,"Connection","","",39],[12,"Date","","",39],[12,"Pragma","","",39],[12,"Trailer","","",39],[12,"TransferEncoding","","",39],[12,"Upgrade","","",39],[12,"Via","","",39],[12,"Warning","","",39],[12,"Accept","","",39],[12,"AcceptCharset","","",39],[12,"AcceptEncoding","","",39],[12,"AcceptLanguage","","",39],[12,"Authorization","","",39],[12,"Expect","","",39],[12,"From","","",39],[12,"Host","","",39],[12,"IfMatch","","",39],[12,"IfModifiedSince","","",39],[12,"IfNoneMatch","","",39],[12,"IfRange","","",39],[12,"IfUnmodifiedSince","","",39],[12,"MaxForwards","","",39],[12,"ProxyAuthorization","","",39],[12,"Range","","",39],[12,"Referer","","",39],[12,"Te","","",39],[12,"UserAgent","","",39],[12,"Allow","","",39],[12,"ContentEncoding","","",39],[12,"ContentLanguage","","",39],[12,"ContentLength","","",39],[12,"ContentLocation","","",39],[12,"ContentMd5","","",39],[12,"ContentRange","","",39],[12,"ContentType","","",39],[12,"Expires","","",39],[12,"LastModified","","",39],[12,"ExtensionHeader","","",39],[1,"HeaderCollection","",""],[11,"cache_control","","",37],[11,"connection","","",37],[11,"date","","",37],[11,"pragma","","",37],[11,"trailer","","",37],[11,"transfer_encoding","","",37],[11,"upgrade","","",37],[11,"via","","",37],[11,"warning","","",37],[11,"accept","","",37],[11,"accept_charset","","",37],[11,"accept_encoding","","",37],[11,"accept_language","","",37],[11,"authorization","","",37],[11,"expect","","",37],[11,"from","","",37],[11,"host","","",37],[11,"if_match","","",37],[11,"if_modified_since","","",37],[11,"if_none_match","","",37],[11,"if_range","","",37],[11,"if_unmodified_since","","",37],[11,"max_forwards","","",37],[11,"proxy_authorization","","",37],[11,"range","","",37],[11,"referer","","",37],[11,"te","","",37],[11,"user_agent","","",37],[11,"allow","","",37],[11,"content_encoding","","",37],[11,"content_language","","",37],[11,"content_length","","",37],[11,"content_location","","",37],[11,"content_md5","","",37],[11,"content_range","","",37],[11,"content_type","","",37],[11,"expires","","",37],[11,"last_modified","","",37],[11,"extensions","","",37],[1,"HeaderCollectionIterator","",""],[0,"response","iron::headers",""],[2,"Header","iron::headers::response",""],[12,"CacheControl","","",42],[12,"Connection","","",42],[12,"Date","","",42],[12,"Pragma","","",42],[12,"Trailer","","",42],[12,"TransferEncoding","","",42],[12,"Upgrade","","",42],[12,"Via","","",42],[12,"Warning","","",42],[12,"AcceptPatch","","",42],[12,"AcceptRanges","","",42],[12,"Age","","",42],[12,"ETag","","",42],[12,"Location","","",42],[12,"ProxyAuthenticate","","",42],[12,"RetryAfter","","",42],[12,"Server","","",42],[12,"Vary","","",42],[12,"WwwAuthenticate","","",42],[12,"Allow","","",42],[12,"ContentEncoding","","",42],[12,"ContentLanguage","","",42],[12,"ContentLength","","",42],[12,"ContentLocation","","",42],[12,"ContentMd5","","",42],[12,"ContentRange","","",42],[12,"ContentType","","",42],[12,"Expires","","",42],[12,"LastModified","","",42],[12,"ExtensionHeader","","",42],[1,"HeaderCollection","",""],[11,"cache_control","","",40],[11,"connection","","",40],[11,"date","","",40],[11,"pragma","","",40],[11,"trailer","","",40],[11,"transfer_encoding","","",40],[11,"upgrade","","",40],[11,"via","","",40],[11,"warning","","",40],[11,"accept_patch","","",40],[11,"accept_ranges","","",40],[11,"age","","",40],[11,"etag","","",40],[11,"location","","",40],[11,"proxy_authenticate","","",40],[11,"retry_after","","",40],[11,"server","","",40],[11,"vary","","",40],[11,"www_authenticate","","",40],[11,"allow","","",40],[11,"content_encoding","","",40],[11,"content_language","","",40],[11,"content_length","","",40],[11,"content_location","","",40],[11,"content_md5","","",40],[11,"content_range","","",40],[11,"content_type","","",40],[11,"expires","","",40],[11,"last_modified","","",40],[11,"extensions","","",40],[1,"HeaderCollectionIterator","",""],[6,"Plugin","iron","An interface for plugins that cache values between calls."],[9,"get","","Return a copy of the plugin's produced value.",50],[9,"get_ref","","Return a reference to the plugin's produced value.",50],[9,"get_mut","","Return a mutable reference to the plugin's produced value.",50],[6,"Error","",""],[9,"name","","",51],[9,"description","","",51],[9,"cause","","",51],[9,"unwrap","","",51],[9,"erase","","",51],[6,"ErrorRefExt","",""],[9,"is","","",52],[9,"downcast","","",52]],"paths":[[1,"Request"],[1,"Url"],[1,"Response"],[1,"Iron"],[1,"TypeMap"],[6,"Handler"],[6,"BeforeMiddleware"],[6,"AfterMiddleware"],[6,"AroundMiddleware"],[6,"Chain"],[1,"ChainBuilder"],[1,"Box"],[1,"Arc"],[1,"FileError"],[1,"Request"],[1,"BufferedStream"],[1,"RequestWriter"],[1,"ResponseReader"],[2,"NetworkStream"],[1,"RequestBuffer"],[2,"RequestUri"],[1,"ResponseWriter"],[2,"Method"],[2,"RangeUnit"],[2,"AcceptableRanges"],[2,"Connection"],[1,"MediaType"],[1,"EntityTag"],[1,"Host"],[2,"TransferCoding"],[2,"ConsumeCommaLWSResult"],[2,"HeaderValueByteIteratorState"],[1,"HeaderValueByteIterator"],[1,"Vec"],[1,"String"],[1,"Url"],[1,"Tm"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[2,"ValueToken"],[2,"ValueToken"],[2,"Status"],[2,"HeaderLineErr"],[6,"WriterUtil"],[6,"HeaderEnum"],[6,"HeaderConvertible"],[6,"Plugin"],[6,"Error"],[6,"ErrorRefExt"]]};
searchIndex['bodyparser'] = {"items":[[0,"","bodyparser","Body Parser Plugin for Iron"],[1,"BodyParser","",""],[10,"clone","","",0],[10,"eval","","",0]],"paths":[[1,"BodyParser"]]};

searchIndex['static_file'] = {"items":[[0,"","static_file","Static file-serving handler."],[1,"StaticWithCache","","Extends the `Static` handler with 304 caching."],[1,"Static","","The static file-serving `Handler`."],[11,"root_path","","The path this handler is serving files from.",0],[10,"new","","Create a new instance of `StaticWithCache` with a given root path.",1],[10,"call","","",1],[10,"clone","","",0],[10,"new","","Create a new instance of `Static` with a given root path.",0],[10,"call","","",0]],"paths":[[1,"Static"],[1,"StaticWithCache"]]};

searchIndex['persistent'] = {"items":[[0,"","persistent","A set of middleware for sharing data between requests in the Iron\nframework."],[1,"State","","Middleware for data that persists between requests with read and write capabilities."],[1,"Read","","Middleware for data that persists between Requests with read-only capabilities."],[1,"Write","","Middleware for data that persists between Requests for data which mostly\nneeds to be written instead of read."],[10,"clone","","",0],[10,"clone","","",1],[10,"clone","","",2],[10,"eval","","",1],[10,"eval","","",0],[10,"eval","","",2],[10,"before","","",1],[10,"after","","",1],[10,"before","","",0],[10,"after","","",0],[10,"before","","",2],[10,"after","","",2],[10,"both","","Construct a new pair of `State` that can be passed directly to `Chain::link`.",1],[10,"one","","Construct a new `State` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",1],[10,"both","","Construct a new pair of `Read` that can be passed directly to `Chain::link`.",0],[10,"one","","Construct a new `Read` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",0],[10,"both","","Construct a new pair of `Write` that can be passed directly to `Chain::link`.",2],[10,"one","","Construct a new `Write` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",2]],"paths":[[1,"Read"],[1,"State"],[1,"Write"]]};

searchIndex['urlencoded'] = {"items":[[0,"","urlencoded","URL Encoded Plugin for Iron."],[1,"UrlEncodedQuery","","Plugin for `Request` that extracts URL encoded data from the URL query string."],[1,"UrlEncodedBody","","Plugin for `Request` that extracts URL encoded data from the request body."],[4,"QueryMap","","Hashmap mapping strings to vectors of strings."],[10,"eval","","",0],[10,"eval","","",1]],"paths":[[1,"UrlEncodedQuery"],[1,"UrlEncodedBody"]]};

searchIndex['mount'] = {"items":[[0,"","mount","`Mount` provides mounting middleware for the Iron framework."],[1,"Mount","","`Mount` is a simple mounting middleware."],[1,"OriginalUrl","","Exposes the original, unmodified path to be stored in `Request::extensions`."],[10,"new","","Creates a new instance of `Mount`.",0],[10,"mount","","Mounts a given `Handler` onto a route.",0],[10,"call","","",0]],"paths":[[1,"Mount"]]};

searchIndex['router'] = {"items":[[0,"","router","`Router` provides a fast router handler for the Iron web framework."],[1,"Router","","`Router` provides an interface for creating complex routes as middleware\nfor the Iron framework."],[10,"new","","`new` constructs a new, blank `Router`.",0],[10,"route","","Add a new route to a `Router`, matching both a method and glob pattern.",0],[10,"get","","Like route, but specialized to the `Get` method.",0],[10,"post","","Like route, but specialized to the `Post` method.",0],[10,"put","","Like route, but specialized to the `Put` method.",0],[10,"delete","","Like route, but specialized to the `Delete` method.",0],[10,"head","","Like route, but specialized to the `Head` method.",0],[10,"patch","","Like route, but specialized to the `Patch` method.",0],[10,"options","","Like route, but specialized to the `Options` method.",0],[10,"error","","Add a Handler to be used for this Router's `catch` method.",0],[10,"call","","",0],[10,"catch","","",0],[10,"new","route-recognizer","",1],[10,"insert","","",1],[10,"find","","",1],[10,"clone","route-recognizer::nfa","",2],[10,"clone_from","","",2],[10,"assert_receiver_is_total_eq","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"ne","","",2],[10,"new","","",2],[10,"insert","","",2],[10,"contains","","",2],[10,"clone","","",3],[10,"clone_from","","",3],[10,"assert_receiver_is_total_eq","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"ne","","",3],[10,"any","","",3],[10,"valid","","",3],[10,"invalid","","",3],[10,"valid_char","","",3],[10,"invalid_char","","",3],[10,"matches","","",3],[10,"clone","","",4],[10,"clone_from","","",4],[10,"new","","",4],[10,"start_capture","","",4],[10,"end_capture","","",4],[10,"extract","","",4],[10,"clone","","",5],[10,"clone_from","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"new","","",5],[10,"new","","",6],[10,"clone","","",7],[10,"clone_from","","",7],[10,"new","","",7],[10,"process","","",7],[10,"get","","",7],[10,"get_mut","","",7],[10,"put","","",7],[10,"put_state","","",7],[10,"acceptance","","",7],[10,"start_capture","","",7],[10,"end_capture","","",7],[10,"metadata","","",7],[10,"clone","route-recognizer","",8],[10,"clone_from","","",8],[10,"new","","",8],[10,"cmp","","",8],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"assert_receiver_is_total_eq","","",8],[10,"fmt","","",1],[10,"clone","","",1],[10,"clone_from","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"ne","","",1],[10,"index","","",1],[10,"new","","",9],[10,"clone","","",10],[10,"clone_from","","",10],[10,"new","","",10],[10,"add","","",10],[10,"recognize","","",10],[1,"Params","router",""]],"paths":[[1,"Router"],[1,"Params"],[1,"CharSet"],[2,"CharacterClass"],[1,"Thread"],[1,"State"],[1,"Match"],[1,"NFA"],[1,"Metadata"],[1,"Match"],[1,"Router"]]};

searchIndex['staticfile'] = {"items":[[0,"","staticfile","Static file-serving middleware."],[1,"Static","","The static file-serving `Middleware`."],[10,"clone","","",0],[10,"new","","Create a new instance of `Static` with a given root path.",0],[10,"favicon","","Create a favicon server from the given filepath.",0],[10,"enter","","",0]],"paths":[[1,"Static"]]};

initSearch(searchIndex);

var searchIndex = {};
searchIndex['mount'] = {"items":[[0,"","mount","`Mount` provides mounting middleware for the Iron framework."],[1,"Mount","","`Mount` is a simple mounting middleware."],[1,"OriginalUrl","","Exposes the original, unmodified path to be stored in `Request::extensions`."],[10,"new","","Creates a new instance of `Mount`.",0],[10,"mount","","Mounts a given `Handler` onto a route.",0],[10,"call","","",0]],"paths":[[1,"Mount"]]};
searchIndex['iron'] = {"items":[[0,"","iron","The main crate for the Iron library."],[1,"Request","","The `Request` given to all `Middleware`."],[11,"url","","The requested URL.",0],[11,"remote_addr","","The originating address of the request.",0],[11,"headers","","The request headers.",0],[11,"body","","The request body.",0],[11,"method","","The request method.",0],[11,"extensions","","Extensible storage for data passed between middleware.",0],[1,"Url","","HTTP/HTTPS URL type for Iron."],[11,"scheme","","The lower-cased scheme of the URL, typically \"http\" or \"https\".",1],[11,"host","","The host field of the URL, probably a domain.",1],[11,"port","","The connection port.",1],[11,"path","","The URL path, the resource to be accessed.",1],[11,"username","","The URL username field, from the userinfo section of the URL.",1],[11,"password","","The URL password field, from the userinfo section of the URL.",1],[11,"query","","The URL query string.",1],[11,"fragment","","The URL fragment.",1],[1,"Iron","","The primary entrance point to `Iron`, a `struct` to instantiate a new server."],[11,"handler","","Iron contains a `Handler`, which it uses to create responses for client\nrequests.",2],[0,"typemap","","Re-exports from the TypeMap crate."],[10,"new","typemap","Create a new, empty TypeMap.",3],[10,"insert","","Insert a value into the map with a specified key type.",3],[10,"find","","Find a value in the map and get a reference to it.",3],[10,"find_mut","","Find a value in the map and get a mutable reference to it.",3],[10,"get","","Find a value in the map and get a reference to it.",3],[10,"get_mut","","Find a value in the map and get a mutable reference to it.",3],[10,"contains","","Check if a key has an associated value stored in the map.",3],[10,"remove","","Remove a value from the map.",3],[10,"entry","","Get the given key's corresponding entry in the map for in-place manipulation.",3],[10,"data","","Read the underlying HashMap",3],[10,"data_mut","","Get a mutable reference to the underlying HashMap",3],[10,"len","","Get the number of values stored in the map.",3],[10,"is_empty","","Return true if the map contains no values.",3],[10,"clear","","Remove all entries from the map.",3],[10,"get","","Get a reference to the entry's value.",4],[10,"get_mut","","Get a mutable reference to the entry's value.",4],[10,"into_mut","","Transform the entry into a mutable reference with the same lifetime as the map.",4],[10,"set","","Set the entry's value and return the previous value.",4],[10,"take","","Move the entry's value out of the map, consuming the entry.",4],[10,"set","","Set the entry's value and return a mutable reference to it.",5],[1,"TypeMap","iron::typemap","A map keyed by types."],[6,"Assoc","","This trait defines the relationship between keys and values in a TypeMap."],[0,"middleware","iron","Iron's Middleware and Handler System"],[1,"ChainBuilder","iron::middleware","The default Chain used in Iron."],[6,"Handler","","`Handler`s are responsible for handling requests by creating Responses from Requests."],[9,"call","","Produce a `Response` from a Request, with the possibility of error.",6],[10,"catch","","If `Handler`'s call method produces an Err, then this method is called\nto produce a `Response` and possibly handle the error.",6],[6,"BeforeMiddleware","","`BeforeMiddleware` are fired before a `Handler` is called inside of a Chain."],[9,"before","","Do whatever work this middleware should do with a `Request` object.",7],[10,"catch","","Try to `catch` an error thrown by this Middleware or a previous `BeforeMiddleware`.",7],[6,"AfterMiddleware","","`AfterMiddleware` are fired after a `Handler` is called inside of a Chain."],[9,"after","","Do whatever work this middleware needs to do with both a `Request` and `Response` objects.",8],[10,"catch","","Try to catch an error thrown by previous `AfterMiddleware`, the `Handler`, or a previous\n`BeforeMiddleware`.",8],[6,"AroundMiddleware","","AroundMiddleware are used to wrap and replace the `Handler` in a `Chain`."],[9,"around","","Produce a `Handler` from this `AroundMiddleware` given another `Handler`.",9],[6,"Chain","","Chain's hold `BeforeMiddleware`, a `Handler`, and `AfterMiddleware` and are responsible\nfor correctly dispatching a `Request` through them."],[9,"new","","Create a new Chain from a `Handler`.",10],[9,"link","","Link both a before and after middleware to the chain at once.",10],[9,"link_before","","Link a `BeforeMiddleware` to the Chain.",10],[9,"link_after","","Link a `AfterMiddleware` to the Chain.",10],[9,"around","","Wrap the Chain's `Handler` using an AroundMiddleware.",10],[10,"new","","Construct a new ChainBuilder from a `Handler`.",11],[10,"new","","",11],[10,"link","","",11],[10,"link_before","","",11],[10,"link_after","","",11],[10,"around","","",11],[10,"call","","",11],[10,"catch","","",11],[10,"call","alloc::boxed","",12],[10,"catch","","",12],[10,"call","alloc::arc","",13],[10,"catch","","",13],[0,"errors","iron","Some common error types for use within Iron and in downstream middleware."],[1,"FileError","iron::errors","The standard Error implementation used to wrap IoErrors\nthat occur when reading or writing files or otherwise\ninteracting with the file system."],[10,"eq","","",14],[10,"ne","","",14],[10,"clone","","",14],[10,"fmt","","",14],[10,"new","","Create a new FileError from an IoError.",14],[10,"unwrap","","Access the original IoError.",14],[10,"name","","",14],[10,"description","","",14],[0,"response","iron","Iron's HTTP Response representation and associated methods."],[1,"Response","iron::response","The response representation given to `Middleware`"],[11,"body","","The body of the response.",15],[11,"headers","","The headers of the response.",15],[11,"status","","The response status-code.",15],[11,"extensions","","A TypeMap to be used as an extensible storage for data\nassociated with this Response.",15],[0,"modifiers","","Defines a series of convenience modifiers for editing Responses"],[1,"ContentType","iron::response::modifiers","A response modifier for setting the content-type header."],[1,"Body","","A response modifier for setting the body of a response."],[1,"Status","","A modifier for setting the status of a response."],[1,"Redirect","","A modifier for creating redirect responses."],[6,"Bodyable","","Something that can be used to set the body of a response."],[9,"set_body","","Set the body of this response, possibly also setting headers.",16],[10,"new","","Create a new ContentType modifier from the parts of a content-type header value.",17],[10,"modify","","",17],[10,"modify","","",18],[10,"set_body","alloc::boxed","",12],[10,"set_body","collections::string","",19],[10,"set_body","collections::vec","",20],[10,"set_body","std::io::fs","",21],[10,"set_body","std::path::posix","Set the body to the contents of the File at this path.",22],[10,"modify","iron::response::modifiers","",23],[10,"modify","","",24],[10,"new","iron::response","Construct a blank Response",15],[10,"status","","Create a new response with the status.",15],[10,"with","","Create a new response with the specified body and status.",15],[10,"redirect","","Create a new Response with the `location` header set to the specified url.",15],[10,"from_file","","Create a response from a file on disk.",15],[10,"fmt","","",15],[10,"extensions","","",15],[10,"extensions_mut","","",15],[10,"new","http::server::response","Create a `ResponseWriter` writing to the specified location",25],[10,"write_content_auto","","Write a response with the specified Content-Type and content; the Content-Length header is\nset based upon the contents",25],[10,"try_write_headers","","Write the Status-Line and headers of the response, if we have not already done so.",25],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",25],[10,"finish_response","","",25],[10,"new","http::buffer","",26],[10,"poke_byte","","Poke a single byte back so it will be read next. For this to make sense, you must have just\nread that byte. If `self.pos` is 0 and `self.max` is not 0 (i.e. if the buffer is just\nfilled\nVery great caution must be used in calling this as it will fail if `self.pos` is 0.",26],[10,"read_byte","","Slightly faster implementation of read_byte than that which is provided by ReaderUtil\n(which just uses `read()`)",26],[10,"finish_response","","Finish off writing a response: this flushes the writer and in case of chunked\nTransfer-Encoding writes the ending zero-length chunk to indicate completion.",26],[10,"read","","Read at most N bytes into `buf`, where N is the minimum of `buf.len()` and the buffer size.",26],[10,"read_at_least","","",26],[10,"read_byte","","",26],[10,"push","","",26],[10,"push_at_least","","",26],[10,"read_exact","","",26],[10,"read_to_end","","",26],[10,"read_to_string","","",26],[10,"read_le_uint_n","","",26],[10,"read_le_int_n","","",26],[10,"read_be_uint_n","","",26],[10,"read_be_int_n","","",26],[10,"read_le_uint","","",26],[10,"read_le_int","","",26],[10,"read_be_uint","","",26],[10,"read_be_int","","",26],[10,"read_be_u64","","",26],[10,"read_be_u32","","",26],[10,"read_be_u16","","",26],[10,"read_be_i64","","",26],[10,"read_be_i32","","",26],[10,"read_be_i16","","",26],[10,"read_be_f64","","",26],[10,"read_be_f32","","",26],[10,"read_le_u64","","",26],[10,"read_le_u32","","",26],[10,"read_le_u16","","",26],[10,"read_le_i64","","",26],[10,"read_le_i32","","",26],[10,"read_le_i16","","",26],[10,"read_le_f64","","",26],[10,"read_le_f32","","",26],[10,"read_u8","","",26],[10,"read_i8","","",26],[10,"write","","",26],[10,"flush","","",26],[10,"flush","","",26],[10,"write_fmt","","",26],[10,"write_str","","",26],[10,"write_line","","",26],[10,"write_char","","",26],[10,"write_int","","",26],[10,"write_uint","","",26],[10,"write_le_uint","","",26],[10,"write_le_int","","",26],[10,"write_be_uint","","",26],[10,"write_be_int","","",26],[10,"write_be_u64","","",26],[10,"write_be_u32","","",26],[10,"write_be_u16","","",26],[10,"write_be_i64","","",26],[10,"write_be_i32","","",26],[10,"write_be_i16","","",26],[10,"write_be_f64","","",26],[10,"write_be_f32","","",26],[10,"write_le_u64","","",26],[10,"write_le_u32","","",26],[10,"write_le_u16","","",26],[10,"write_le_i64","","",26],[10,"write_le_i32","","",26],[10,"write_le_i16","","",26],[10,"write_le_f64","","",26],[10,"write_le_f32","","",26],[10,"write_u8","","",26],[10,"write_i8","","",26],[10,"new","http::client::request","Create a `RequestWriter` writing to the specified location",27],[10,"new_request","","",27],[10,"try_connect","","Connect to the remote host if not already connected.",27],[10,"connect","","Connect to the remote host; fails if already connected.\nReturns ``true`` upon success and ``false`` upon failure (also use conditions).",27],[10,"try_write_headers","","Write the Request-Line and headers of the response, if we have not already done so.",27],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",27],[10,"read_response","","Send the request and construct a `ResponseReader` out of it.",27],[10,"write","","",27],[10,"flush","","",27],[10,"flush","","",27],[10,"write_fmt","","",27],[10,"write_str","","",27],[10,"write_line","","",27],[10,"write_char","","",27],[10,"write_int","","",27],[10,"write_uint","","",27],[10,"write_le_uint","","",27],[10,"write_le_int","","",27],[10,"write_be_uint","","",27],[10,"write_be_int","","",27],[10,"write_be_u64","","",27],[10,"write_be_u32","","",27],[10,"write_be_u16","","",27],[10,"write_be_i64","","",27],[10,"write_be_i32","","",27],[10,"write_be_i16","","",27],[10,"write_be_f64","","",27],[10,"write_be_f32","","",27],[10,"write_le_u64","","",27],[10,"write_le_u32","","",27],[10,"write_le_u16","","",27],[10,"write_le_i64","","",27],[10,"write_le_i32","","",27],[10,"write_le_i16","","",27],[10,"write_le_f64","","",27],[10,"write_le_f32","","",27],[10,"write_u8","","",27],[10,"write_i8","","",27],[10,"construct","http::client::response","",28],[10,"read","","",28],[10,"read_at_least","","",28],[10,"read_byte","","",28],[10,"push","","",28],[10,"push_at_least","","",28],[10,"read_exact","","",28],[10,"read_to_end","","",28],[10,"read_to_string","","",28],[10,"read_le_uint_n","","",28],[10,"read_le_int_n","","",28],[10,"read_be_uint_n","","",28],[10,"read_be_int_n","","",28],[10,"read_le_uint","","",28],[10,"read_le_int","","",28],[10,"read_be_uint","","",28],[10,"read_be_int","","",28],[10,"read_be_u64","","",28],[10,"read_be_u32","","",28],[10,"read_be_u16","","",28],[10,"read_be_i64","","",28],[10,"read_be_i32","","",28],[10,"read_be_i16","","",28],[10,"read_be_f64","","",28],[10,"read_be_f32","","",28],[10,"read_le_u64","","",28],[10,"read_le_u32","","",28],[10,"read_le_u16","","",28],[10,"read_le_i64","","",28],[10,"read_le_i32","","",28],[10,"read_le_i16","","",28],[10,"read_le_f64","","",28],[10,"read_le_f32","","",28],[10,"read_u8","","",28],[10,"read_i8","","",28],[10,"connect","http::client::sslclients::openssl","",29],[10,"read","","",29],[10,"read_at_least","","",29],[10,"read_byte","","",29],[10,"push","","",29],[10,"push_at_least","","",29],[10,"read_exact","","",29],[10,"read_to_end","","",29],[10,"read_to_string","","",29],[10,"read_le_uint_n","","",29],[10,"read_le_int_n","","",29],[10,"read_be_uint_n","","",29],[10,"read_be_int_n","","",29],[10,"read_le_uint","","",29],[10,"read_le_int","","",29],[10,"read_be_uint","","",29],[10,"read_be_int","","",29],[10,"read_be_u64","","",29],[10,"read_be_u32","","",29],[10,"read_be_u16","","",29],[10,"read_be_i64","","",29],[10,"read_be_i32","","",29],[10,"read_be_i16","","",29],[10,"read_be_f64","","",29],[10,"read_be_f32","","",29],[10,"read_le_u64","","",29],[10,"read_le_u32","","",29],[10,"read_le_u16","","",29],[10,"read_le_i64","","",29],[10,"read_le_i32","","",29],[10,"read_le_i16","","",29],[10,"read_le_f64","","",29],[10,"read_le_f32","","",29],[10,"read_u8","","",29],[10,"read_i8","","",29],[10,"write","","",29],[10,"flush","","",29],[10,"flush","","",29],[10,"write_fmt","","",29],[10,"write_str","","",29],[10,"write_line","","",29],[10,"write_char","","",29],[10,"write_int","","",29],[10,"write_uint","","",29],[10,"write_le_uint","","",29],[10,"write_le_int","","",29],[10,"write_be_uint","","",29],[10,"write_be_int","","",29],[10,"write_be_u64","","",29],[10,"write_be_u32","","",29],[10,"write_be_u16","","",29],[10,"write_be_i64","","",29],[10,"write_be_i32","","",29],[10,"write_be_i16","","",29],[10,"write_be_f64","","",29],[10,"write_be_f32","","",29],[10,"write_le_u64","","",29],[10,"write_le_u32","","",29],[10,"write_le_u16","","",29],[10,"write_le_i64","","",29],[10,"write_le_i32","","",29],[10,"write_le_i16","","",29],[10,"write_le_f64","","",29],[10,"write_le_f32","","",29],[10,"write_u8","","",29],[10,"write_i8","","",29],[10,"new","http::server::request","",30],[10,"read_request_line","","",30],[10,"read_header","","Read a header (name, value) pair.",30],[10,"read","","",30],[10,"read_at_least","","",30],[10,"read_byte","","",30],[10,"push","","",30],[10,"push_at_least","","",30],[10,"read_exact","","",30],[10,"read_to_end","","",30],[10,"read_to_string","","",30],[10,"read_le_uint_n","","",30],[10,"read_le_int_n","","",30],[10,"read_be_uint_n","","",30],[10,"read_be_int_n","","",30],[10,"read_le_uint","","",30],[10,"read_le_int","","",30],[10,"read_be_uint","","",30],[10,"read_be_int","","",30],[10,"read_be_u64","","",30],[10,"read_be_u32","","",30],[10,"read_be_u16","","",30],[10,"read_be_i64","","",30],[10,"read_be_i32","","",30],[10,"read_be_i16","","",30],[10,"read_be_f64","","",30],[10,"read_be_f32","","",30],[10,"read_le_u64","","",30],[10,"read_le_u32","","",30],[10,"read_le_u16","","",30],[10,"read_le_i64","","",30],[10,"read_le_i32","","",30],[10,"read_le_i16","","",30],[10,"read_le_f64","","",30],[10,"read_le_f32","","",30],[10,"read_u8","","",30],[10,"read_i8","","",30],[10,"assert_receiver_is_total_eq","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"ne","","",31],[10,"fmt","","",31],[10,"load","","Get a response from an open socket.",32],[10,"write","http::server::response","",25],[10,"flush","","",25],[10,"flush","","",25],[10,"write_fmt","","",25],[10,"write_str","","",25],[10,"write_line","","",25],[10,"write_char","","",25],[10,"write_int","","",25],[10,"write_uint","","",25],[10,"write_le_uint","","",25],[10,"write_le_int","","",25],[10,"write_be_uint","","",25],[10,"write_be_int","","",25],[10,"write_be_u64","","",25],[10,"write_be_u32","","",25],[10,"write_be_u16","","",25],[10,"write_be_i64","","",25],[10,"write_be_i32","","",25],[10,"write_be_i16","","",25],[10,"write_be_f64","","",25],[10,"write_be_f32","","",25],[10,"write_le_u64","","",25],[10,"write_le_u32","","",25],[10,"write_le_u16","","",25],[10,"write_le_i64","","",25],[10,"write_le_i32","","",25],[10,"write_le_i16","","",25],[10,"write_le_f64","","",25],[10,"write_le_f32","","",25],[10,"write_u8","","",25],[10,"write_i8","","",25],[10,"hash","http::method","",33],[10,"clone","","",33],[10,"clone_from","","",33],[10,"assert_receiver_is_total_eq","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"ne","","",33],[10,"from_str","","Get a *known* `Method` from an *ASCII* string, regardless of case.",33],[10,"fmt","","",33],[10,"from_str_or_new","","Get a `Method` from an *ASCII* string.",33],[10,"assert_receiver_is_total_eq","http::headers::accept_ranges","",34],[10,"eq","","",34],[10,"ne","","",34],[10,"ne","","",34],[10,"clone","","",34],[10,"clone_from","","",34],[10,"assert_receiver_is_total_eq","","",35],[10,"eq","","",35],[10,"ne","","",35],[10,"ne","","",35],[10,"clone","","",35],[10,"clone_from","","",35],[10,"from_stream","","",35],[10,"to_stream","","",35],[10,"http_value","","",35],[10,"to_stream","","",35],[10,"assert_receiver_is_total_eq","http::headers::connection","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"ne","","",36],[10,"clone","","",36],[10,"clone_from","","",36],[10,"fmt","","",36],[10,"from_stream","","",36],[10,"to_stream","","",36],[10,"http_value","","",36],[10,"to_stream","","",36],[10,"assert_receiver_is_total_eq","http::headers::content_type","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"ne","","",37],[10,"clone","","",37],[10,"clone_from","","",37],[10,"new","","",37],[10,"fmt","","",37],[10,"from_stream","","",37],[10,"to_stream","","",37],[10,"http_value","","",37],[10,"to_stream","","",37],[10,"assert_receiver_is_total_eq","http::headers::etag","",38],[10,"eq","","",38],[10,"ne","","",38],[10,"ne","","",38],[10,"clone","","",38],[10,"clone_from","","",38],[10,"fmt","","",38],[10,"from_stream","","",38],[10,"to_stream","","",38],[10,"http_value","","",38],[10,"to_stream","","",38],[10,"assert_receiver_is_total_eq","http::headers::host","",39],[10,"eq","","",39],[10,"ne","","",39],[10,"ne","","",39],[10,"clone","","",39],[10,"clone_from","","",39],[10,"fmt","","",39],[10,"from_stream","","",39],[10,"http_value","","",39],[10,"to_stream","","",39],[10,"assert_receiver_is_total_eq","http::headers::transfer_encoding","",40],[10,"eq","","",40],[10,"ne","","",40],[10,"ne","","",40],[10,"clone","","",40],[10,"clone_from","","",40],[10,"from_stream","","",40],[10,"to_stream","","",40],[10,"http_value","","",40],[10,"to_stream","","",40],[10,"assert_receiver_is_total_eq","http::headers","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"ne","","",41],[10,"clone","","",41],[10,"clone_from","","",41],[10,"assert_receiver_is_total_eq","","",42],[10,"eq","","",42],[10,"ne","","",42],[10,"ne","","",42],[10,"new","","",43],[10,"verify_consumed","","Check that the entire header value has been consumed.",43],[10,"some_if_consumed","","Turn a constructed header value into an Option: Some(value) if the header value is consumed\nor None if it is not, thus indicating: \"I'm finished and expect nothing more. Anything more\nis an error.\"",43],[10,"consume_optional_lws","","Consume optional `*LWS`. That is, zero or more of SP and HT, until it\ngets to something other than SP and HT or gets to the end of the header.",43],[10,"consume_lws","","Consume `1*LWS`. That is, one or more of SP and HT, until it gets to\nsomething other than SP and HT or gets to the end of the header.",43],[10,"consume_comma_lws","","Return values:\n- CommaConsumed if there was a comma and it was consumed;\n- EndOfValue if the header value has been completely consumed;\n- ErrCommaNotFound if the next thing wasn't a comma (this is an error state)",43],[10,"read_quoted_string","","Read a quoted-string from the current position.\nIf the quoted-string is not begun immediately or the header ends before it is completed,\nthen None is returned; TODO: decide if I can return the bytes read (at present, escapes and\ndouble quote would be lost if I did that).",43],[10,"read_token_or_quoted_string","","Read a token (RFC 2616 definition) from the header value.",43],[10,"read_token","","Read a token (RFC 2616 definition) from the header value.",43],[10,"next","","",43],[10,"size_hint","","",43],[10,"chain","","",43],[10,"zip","","",43],[10,"map","","",43],[10,"filter","","",43],[10,"filter_map","","",43],[10,"enumerate","","",43],[10,"peekable","","",43],[10,"skip_while","","",43],[10,"take_while","","",43],[10,"skip","","",43],[10,"take","","",43],[10,"scan","","",43],[10,"flat_map","","",43],[10,"fuse","","",43],[10,"inspect","","",43],[10,"by_ref","","",43],[10,"collect","","",43],[10,"nth","","",43],[10,"last","","",43],[10,"fold","","",43],[10,"count","","",43],[10,"all","","",43],[10,"any","","",43],[10,"find","","",43],[10,"position","","",43],[10,"max_by","","",43],[10,"min_by","","",43],[10,"from_stream","collections::vec","",20],[10,"to_stream","","",20],[10,"http_value","","",20],[10,"to_stream","","",20],[10,"from_stream","collections::string","",19],[10,"to_stream","","",19],[10,"http_value","","",19],[10,"to_stream","","",19],[10,"from_stream","url","",44],[10,"http_value","","",44],[10,"to_stream","","",44],[10,"from_stream","http::method","",33],[10,"http_value","","",33],[10,"to_stream","","",33],[10,"from_stream","time","",45],[10,"http_value","","",45],[10,"to_stream","","",45],[10,"clone","http::headers::request","",46],[10,"clone_from","","",46],[10,"new","","",46],[10,"insert","","Consume a header, putting it into this structure.",46],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",46],[10,"iter","","",46],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",46],[10,"next","","",47],[10,"size_hint","","",47],[10,"chain","","",47],[10,"zip","","",47],[10,"map","","",47],[10,"filter","","",47],[10,"filter_map","","",47],[10,"enumerate","","",47],[10,"peekable","","",47],[10,"skip_while","","",47],[10,"take_while","","",47],[10,"skip","","",47],[10,"take","","",47],[10,"scan","","",47],[10,"flat_map","","",47],[10,"fuse","","",47],[10,"inspect","","",47],[10,"by_ref","","",47],[10,"collect","","",47],[10,"nth","","",47],[10,"last","","",47],[10,"fold","","",47],[10,"count","","",47],[10,"all","","",47],[10,"any","","",47],[10,"find","","",47],[10,"position","","",47],[10,"max_by","","",47],[10,"min_by","","",47],[10,"header_name","","",48],[10,"header_value","","",48],[10,"write_header","","",48],[10,"value_from_stream","","",48],[10,"clone","http::headers::response","",49],[10,"clone_from","","",49],[10,"new","","",49],[10,"insert","","Consume a header, putting it into this structure.",49],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",49],[10,"iter","","",49],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",49],[10,"next","","",50],[10,"size_hint","","",50],[10,"chain","","",50],[10,"zip","","",50],[10,"map","","",50],[10,"filter","","",50],[10,"filter_map","","",50],[10,"enumerate","","",50],[10,"peekable","","",50],[10,"skip_while","","",50],[10,"take_while","","",50],[10,"skip","","",50],[10,"take","","",50],[10,"scan","","",50],[10,"flat_map","","",50],[10,"fuse","","",50],[10,"inspect","","",50],[10,"by_ref","","",50],[10,"collect","","",50],[10,"nth","","",50],[10,"last","","",50],[10,"fold","","",50],[10,"count","","",50],[10,"all","","",50],[10,"any","","",50],[10,"find","","",50],[10,"position","","",50],[10,"max_by","","",50],[10,"min_by","","",50],[10,"header_name","","",51],[10,"header_value","","",51],[10,"write_header","","",51],[10,"value_from_stream","","",51],[10,"fmt","http::rfc2616::content_coding","",52],[10,"from_str","","",52],[10,"fmt","http::rfc2616::transfer_coding","",53],[10,"clone","http::status","",54],[10,"clone_from","","",54],[10,"eq","","",54],[10,"ne","","",54],[10,"ne","","",54],[10,"assert_receiver_is_total_eq","","",54],[10,"code","","Get the status code",54],[10,"reason","","Get the reason phrase",54],[10,"from_code_and_reason","","Get a status from the code and reason",54],[10,"fmt","","",54],[10,"fmt","","",54],[10,"to_i64","","Equivalent to `Some(self.code() as i64)`",54],[10,"to_u64","","Equivalent to `Some(self.code() as u64)`",54],[10,"to_int","","",54],[10,"to_i8","","",54],[10,"to_i16","","",54],[10,"to_i32","","",54],[10,"to_uint","","",54],[10,"to_u8","","",54],[10,"to_u16","","",54],[10,"to_u32","","",54],[10,"to_f32","","",54],[10,"to_f64","","",54],[10,"from_i64","","Get a *registered* status code from the number of its status code.",54],[10,"from_u64","","Get a *registered* status code from the number of its status code.",54],[10,"from_int","","",54],[10,"from_i8","","",54],[10,"from_i16","","",54],[10,"from_i32","","",54],[10,"from_uint","","",54],[10,"from_u8","","",54],[10,"from_u16","","",54],[10,"from_u32","","",54],[10,"from_f32","","",54],[10,"from_f64","","",54],[1,"HttpResponse","iron::response",""],[11,"headers","","",25],[11,"status","","",25],[10,"clone","iron","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"parse","","Create a URL from a string.",1],[10,"from_generic_url","","Create a `Url` from a `rust-url` `Url`.",1],[10,"into_generic_url","","Create a `rust-url` `Url` from a `Url`.",1],[10,"fmt","","",1],[10,"encode","","",1],[10,"decode","","",1],[10,"fmt","","",0],[10,"from_http","","Create a request from an HttpRequest.",0],[10,"extensions","","",0],[10,"extensions_mut","","",0],[10,"listen","","Kick off the server process.",2],[10,"listen_with","","Kick off the server process with X threads.",2],[10,"new","","Instantiate a new instance of `Iron`.",2],[4,"IronError","",""],[4,"IronResult","",""],[1,"TypeMap","","A map keyed by types."],[0,"status","",""],[2,"Status","iron::status","HTTP status code"],[12,"Continue","","",54],[12,"SwitchingProtocols","","",54],[12,"Processing","","",54],[12,"Ok","","",54],[12,"Created","","",54],[12,"Accepted","","",54],[12,"NonAuthoritativeInformation","","",54],[12,"NoContent","","",54],[12,"ResetContent","","",54],[12,"PartialContent","","",54],[12,"MultiStatus","","",54],[12,"AlreadyReported","","",54],[12,"ImUsed","","",54],[12,"MultipleChoices","","",54],[12,"MovedPermanently","","",54],[12,"Found","","",54],[12,"SeeOther","","",54],[12,"NotModified","","",54],[12,"UseProxy","","",54],[12,"SwitchProxy","","",54],[12,"TemporaryRedirect","","",54],[12,"PermanentRedirect","","",54],[12,"BadRequest","","",54],[12,"Unauthorized","","",54],[12,"PaymentRequired","","",54],[12,"Forbidden","","",54],[12,"NotFound","","",54],[12,"MethodNotAllowed","","",54],[12,"NotAcceptable","","",54],[12,"ProxyAuthenticationRequired","","",54],[12,"RequestTimeout","","",54],[12,"Conflict","","",54],[12,"Gone","","",54],[12,"LengthRequired","","",54],[12,"PreconditionFailed","","",54],[12,"RequestEntityTooLarge","","",54],[12,"RequestUriTooLong","","",54],[12,"UnsupportedMediaType","","",54],[12,"RequestedRangeNotSatisfiable","","",54],[12,"ExpectationFailed","","",54],[12,"ImATeapot","","",54],[12,"AuthenticationTimeout","","",54],[12,"UnprocessableEntity","","",54],[12,"Locked","","",54],[12,"FailedDependency","","",54],[12,"MethodFailure","","",54],[12,"UnorderedCollection","","",54],[12,"UpgradeRequired","","",54],[12,"PreconditionRequired","","",54],[12,"TooManyRequests","","",54],[12,"RequestHeaderFieldsTooLarge","","",54],[12,"UnavailableForLegalReasons","","",54],[12,"InternalServerError","","",54],[12,"NotImplemented","","",54],[12,"BadGateway","","",54],[12,"ServiceUnavailable","","",54],[12,"GatewayTimeout","","",54],[12,"HttpVersionNotSupported","","",54],[12,"VariantAlsoNegotiates","","",54],[12,"InsufficientStorage","","",54],[12,"LoopDetected","","",54],[12,"NotExtended","","",54],[12,"NetworkAuthenticationRequired","","",54],[12,"UnregisteredStatus","","",54],[0,"method","iron",""],[2,"Method","iron::method","HTTP methods, as defined in RFC 2616, §5.1.1."],[12,"Options","","",33],[12,"Get","","",33],[12,"Head","","",33],[12,"Post","","",33],[12,"Put","","",33],[12,"Delete","","",33],[12,"Trace","","",33],[12,"Connect","","",33],[12,"Patch","","",33],[12,"ExtensionMethod","","",33],[0,"headers","iron","Types and utilities for working with headers in HTTP requests and responses."],[2,"HeaderLineErr","iron::headers",""],[12,"EndOfFile","","",55],[12,"EndOfHeaders","","",55],[12,"MalformedHeaderValue","","",55],[12,"MalformedHeaderSyntax","","",55],[0,"test_utils","",""],[3,"from_stream_with_str","iron::headers::test_utils",""],[3,"to_stream_into_str","",""],[3,"assert_invalid","",""],[3,"assert_conversion_correct","",""],[3,"assert_interpretation_correct","",""],[0,"serialization_utils","iron::headers","Utility functions for assisting with conversion of headers from and to the HTTP text form."],[3,"normalise_header_name","iron::headers::serialization_utils","Normalise an HTTP header name."],[3,"comma_split","","Split a value on commas, as is common for HTTP headers."],[3,"comma_split_iter","",""],[6,"WriterUtil","",""],[9,"write_maybe_quoted_string","","",56],[9,"write_quoted_string","","",56],[9,"write_parameter","","",56],[9,"write_parameters","","",56],[9,"write_quality","","",56],[9,"write_token","","",56],[3,"comma_join","","Join a vector of values with commas, as is common for HTTP headers."],[3,"push_maybe_quoted_string","","Push a ( token | quoted-string ) onto a string and return it again"],[3,"maybe_quoted_string","","Make a string into a ( token | quoted-string ), preferring a token"],[3,"push_quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"unquote_string","","Parse a quoted-string. Returns ``None`` if the string is not a valid quoted-string."],[3,"maybe_unquote_string","","Parse a ( token | quoted-string ). Returns ``None`` if it is not valid."],[3,"push_parameter","",""],[3,"push_parameters","",""],[0,"accept_ranges","iron::headers","The Accept-Ranges request header, defined in RFC 2616, Section 14.5."],[2,"RangeUnit","iron::headers::accept_ranges",""],[12,"Bytes","","",34],[12,"OtherRangeUnit","","",34],[2,"AcceptableRanges","",""],[12,"RangeUnits","","",35],[12,"NoAcceptableRanges","","",35],[0,"connection","iron::headers","The Connection general header, defined in RFC 2616, Section 14.10."],[2,"Connection","iron::headers::connection","A value for the Connection header. Note that should it be a ``Token``, the string is in\nnormalised header case (e.g. \"Keep-Alive\")."],[12,"Token","","",36],[12,"Close","","",36],[0,"content_type","iron::headers","The Content-Type entity header, defined in RFC 2616, Section 14.17."],[1,"MediaType","iron::headers::content_type",""],[11,"type_","","",37],[11,"subtype","","",37],[11,"parameters","","",37],[0,"etag","iron::headers",""],[1,"EntityTag","iron::headers::etag",""],[11,"weak","","",38],[11,"opaque_tag","","",38],[3,"weak_etag","",""],[3,"strong_etag","",""],[0,"host","iron::headers","The Host request header, defined in RFC 2616, Section 14.23."],[1,"Host","iron::headers::host","A simple little thing for the host of a request"],[11,"name","","The name of the host that was requested",39],[11,"port","","If unspecified, assume the default port was used (80 for HTTP, 443 for HTTPS).\nIn that case, you shouldn't need to worry about it in URLs that you build, provided you\ninclude the scheme.",39],[0,"transfer_encoding","iron::headers","The Transfer-Encoding request header, defined in RFC 2616, sections 14.41 and 3.6."],[2,"TransferCoding","iron::headers::transfer_encoding","RFC 2616, section 3.6:"],[12,"Chunked","","",40],[12,"TransferExtension","","",40],[4,"DeltaSeconds","iron::headers",""],[2,"ConsumeCommaLWSResult","",""],[12,"CommaConsumed","","",41],[12,"EndOfValue","","",41],[12,"ErrCommaNotFound","","",41],[6,"HeaderEnum","",""],[9,"header_name","","",57],[9,"header_value","","",57],[9,"write_header","","",57],[9,"value_from_stream","","Return values:",57],[3,"header_enum_from_stream","","Shifted out of being a default method to fix an ICE (not yet reported, TODO)"],[1,"HeaderValueByteIterator","","An iterator over the bytes of a header value.\nThis ensures one cannot read past the end of a header mistakenly and that linear white space is\nhandled correctly so that nothing else needs to worry about it. Any linear whitespace (multiple\nspaces outside of a quoted-string) is compacted into a single SP."],[11,"reader","","",43],[11,"next_byte","","This field serves two purposes. *During* iteration, it will typically be ``None``, but\ncertain cases will cause it to be a ``Some``, meaning that the next ``next()`` call will\nreturn that value rather than reading a new byte. At the *end* of iteration (after\n``next()`` has returned ``None``), it will be the extra byte which it has had to consume\nfrom the stream because of the possibility of linear white space of the form ``CR LF SP``.\nIt is guaranteed that if ``self.state == Finished`` this will be a ``Some``.",43],[11,"at_start","","",43],[6,"HeaderConvertible","","A datatype for headers."],[9,"from_stream","","Read a header value from an iterator over the raw value.",58],[9,"to_stream","","Write the HTTP value of the header to the stream.",58],[9,"http_value","","The value of the header as it would be written for an HTTP header.",58],[6,"CommaListHeaderConvertible","","A header with multiple comma-separated values. Implement this and a HeaderConvertible\nimplementation for Vec<T> is yours for free—just make sure your reading does not consume the\ncomma."],[0,"request","",""],[2,"Header","iron::headers::request",""],[12,"CacheControl","","",48],[12,"Connection","","",48],[12,"Date","","",48],[12,"Pragma","","",48],[12,"Trailer","","",48],[12,"TransferEncoding","","",48],[12,"Upgrade","","",48],[12,"Via","","",48],[12,"Warning","","",48],[12,"Accept","","",48],[12,"AcceptCharset","","",48],[12,"AcceptEncoding","","",48],[12,"AcceptLanguage","","",48],[12,"Authorization","","",48],[12,"Expect","","",48],[12,"From","","",48],[12,"Host","","",48],[12,"IfMatch","","",48],[12,"IfModifiedSince","","",48],[12,"IfNoneMatch","","",48],[12,"IfRange","","",48],[12,"IfUnmodifiedSince","","",48],[12,"MaxForwards","","",48],[12,"ProxyAuthorization","","",48],[12,"Range","","",48],[12,"Referer","","",48],[12,"Te","","",48],[12,"UserAgent","","",48],[12,"Allow","","",48],[12,"ContentEncoding","","",48],[12,"ContentLanguage","","",48],[12,"ContentLength","","",48],[12,"ContentLocation","","",48],[12,"ContentMd5","","",48],[12,"ContentRange","","",48],[12,"ContentType","","",48],[12,"Expires","","",48],[12,"LastModified","","",48],[12,"ExtensionHeader","","",48],[1,"HeaderCollection","",""],[11,"cache_control","","",46],[11,"connection","","",46],[11,"date","","",46],[11,"pragma","","",46],[11,"trailer","","",46],[11,"transfer_encoding","","",46],[11,"upgrade","","",46],[11,"via","","",46],[11,"warning","","",46],[11,"accept","","",46],[11,"accept_charset","","",46],[11,"accept_encoding","","",46],[11,"accept_language","","",46],[11,"authorization","","",46],[11,"expect","","",46],[11,"from","","",46],[11,"host","","",46],[11,"if_match","","",46],[11,"if_modified_since","","",46],[11,"if_none_match","","",46],[11,"if_range","","",46],[11,"if_unmodified_since","","",46],[11,"max_forwards","","",46],[11,"proxy_authorization","","",46],[11,"range","","",46],[11,"referer","","",46],[11,"te","","",46],[11,"user_agent","","",46],[11,"allow","","",46],[11,"content_encoding","","",46],[11,"content_language","","",46],[11,"content_length","","",46],[11,"content_location","","",46],[11,"content_md5","","",46],[11,"content_range","","",46],[11,"content_type","","",46],[11,"expires","","",46],[11,"last_modified","","",46],[11,"extensions","","",46],[1,"HeaderCollectionIterator","",""],[0,"response","iron::headers",""],[2,"Header","iron::headers::response",""],[12,"CacheControl","","",51],[12,"Connection","","",51],[12,"Date","","",51],[12,"Pragma","","",51],[12,"Trailer","","",51],[12,"TransferEncoding","","",51],[12,"Upgrade","","",51],[12,"Via","","",51],[12,"Warning","","",51],[12,"AcceptPatch","","",51],[12,"AcceptRanges","","",51],[12,"Age","","",51],[12,"ETag","","",51],[12,"Location","","",51],[12,"ProxyAuthenticate","","",51],[12,"RetryAfter","","",51],[12,"Server","","",51],[12,"Vary","","",51],[12,"WwwAuthenticate","","",51],[12,"Allow","","",51],[12,"ContentEncoding","","",51],[12,"ContentLanguage","","",51],[12,"ContentLength","","",51],[12,"ContentLocation","","",51],[12,"ContentMd5","","",51],[12,"ContentRange","","",51],[12,"ContentType","","",51],[12,"Expires","","",51],[12,"LastModified","","",51],[12,"ExtensionHeader","","",51],[1,"HeaderCollection","",""],[11,"cache_control","","",49],[11,"connection","","",49],[11,"date","","",49],[11,"pragma","","",49],[11,"trailer","","",49],[11,"transfer_encoding","","",49],[11,"upgrade","","",49],[11,"via","","",49],[11,"warning","","",49],[11,"accept_patch","","",49],[11,"accept_ranges","","",49],[11,"age","","",49],[11,"etag","","",49],[11,"location","","",49],[11,"proxy_authenticate","","",49],[11,"retry_after","","",49],[11,"server","","",49],[11,"vary","","",49],[11,"www_authenticate","","",49],[11,"allow","","",49],[11,"content_encoding","","",49],[11,"content_language","","",49],[11,"content_length","","",49],[11,"content_location","","",49],[11,"content_md5","","",49],[11,"content_range","","",49],[11,"content_type","","",49],[11,"expires","","",49],[11,"last_modified","","",49],[11,"extensions","","",49],[1,"HeaderCollectionIterator","",""],[6,"Plugin","iron","An interface for plugins that cache values between calls."],[9,"get","","Return a copy of the plugin's produced value.",59],[9,"get_ref","","Return a reference to the plugin's produced value.",59],[9,"get_mut","","Return a mutable reference to the plugin's produced value.",59],[6,"Set","","A blanket trait providing the set and set_mut methods for all types."],[9,"set","","Modify self using the provided modifier.",60],[9,"set_mut","","Modify self through a mutable reference with the provided modifier.",60],[6,"Error","",""],[9,"name","","",61],[9,"description","","",61],[9,"cause","","",61],[6,"ErrorRefExt","",""],[9,"is","","",62],[9,"downcast","","",62]],"paths":[[1,"Request"],[1,"Url"],[1,"Iron"],[1,"TypeMap"],[1,"OccupiedEntry"],[1,"VacantEntry"],[6,"Handler"],[6,"BeforeMiddleware"],[6,"AfterMiddleware"],[6,"AroundMiddleware"],[6,"Chain"],[1,"ChainBuilder"],[1,"Box"],[1,"Arc"],[1,"FileError"],[1,"Response"],[6,"Bodyable"],[1,"ContentType"],[1,"Body"],[1,"String"],[1,"Vec"],[1,"File"],[1,"Path"],[1,"Status"],[1,"Redirect"],[1,"HttpResponse"],[1,"BufferedStream"],[1,"RequestWriter"],[1,"ResponseReader"],[2,"NetworkStream"],[1,"RequestBuffer"],[2,"RequestUri"],[1,"Request"],[2,"Method"],[2,"RangeUnit"],[2,"AcceptableRanges"],[2,"Connection"],[1,"MediaType"],[1,"EntityTag"],[1,"Host"],[2,"TransferCoding"],[2,"ConsumeCommaLWSResult"],[2,"HeaderValueByteIteratorState"],[1,"HeaderValueByteIterator"],[1,"Url"],[1,"Tm"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[2,"ValueToken"],[2,"ValueToken"],[2,"Status"],[2,"HeaderLineErr"],[6,"WriterUtil"],[6,"HeaderEnum"],[6,"HeaderConvertible"],[6,"Plugin"],[6,"Set"],[6,"Error"],[6,"ErrorRefExt"]]};

searchIndex['router'] = {"items":[[0,"","router","`Router` provides a fast router handler for the Iron web framework."],[1,"Router","","`Router` provides an interface for creating complex routes as middleware\nfor the Iron framework."],[10,"new","","`new` constructs a new, blank `Router`.",0],[10,"route","","Add a new route to a `Router`, matching both a method and glob pattern.",0],[10,"get","","Like route, but specialized to the `Get` method.",0],[10,"post","","Like route, but specialized to the `Post` method.",0],[10,"put","","Like route, but specialized to the `Put` method.",0],[10,"delete","","Like route, but specialized to the `Delete` method.",0],[10,"head","","Like route, but specialized to the `Head` method.",0],[10,"patch","","Like route, but specialized to the `Patch` method.",0],[10,"options","","Like route, but specialized to the `Options` method.",0],[10,"error","","Add a Handler to be used for this Router's `catch` method.",0],[10,"call","","",0],[10,"catch","","",0],[10,"new","route-recognizer","",1],[10,"insert","","",1],[10,"find","","",1],[10,"clone","route-recognizer::nfa","",2],[10,"clone_from","","",2],[10,"assert_receiver_is_total_eq","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"ne","","",2],[10,"new","","",2],[10,"insert","","",2],[10,"contains","","",2],[10,"clone","","",3],[10,"clone_from","","",3],[10,"assert_receiver_is_total_eq","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"ne","","",3],[10,"any","","",3],[10,"valid","","",3],[10,"invalid","","",3],[10,"valid_char","","",3],[10,"invalid_char","","",3],[10,"matches","","",3],[10,"clone","","",4],[10,"clone_from","","",4],[10,"new","","",4],[10,"start_capture","","",4],[10,"end_capture","","",4],[10,"extract","","",4],[10,"clone","","",5],[10,"clone_from","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"new","","",5],[10,"new","","",6],[10,"clone","","",7],[10,"clone_from","","",7],[10,"new","","",7],[10,"process","","",7],[10,"get","","",7],[10,"get_mut","","",7],[10,"put","","",7],[10,"put_state","","",7],[10,"acceptance","","",7],[10,"start_capture","","",7],[10,"end_capture","","",7],[10,"metadata","","",7],[10,"clone","route-recognizer","",8],[10,"clone_from","","",8],[10,"new","","",8],[10,"cmp","","",8],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"assert_receiver_is_total_eq","","",8],[10,"fmt","","",1],[10,"clone","","",1],[10,"clone_from","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"ne","","",1],[10,"index","","",1],[10,"new","","",9],[10,"clone","","",10],[10,"clone_from","","",10],[10,"new","","",10],[10,"add","","",10],[10,"recognize","","",10],[1,"Params","router",""]],"paths":[[1,"Router"],[1,"Params"],[1,"CharSet"],[2,"CharacterClass"],[1,"Thread"],[1,"State"],[1,"Match"],[1,"NFA"],[1,"Metadata"],[1,"Match"],[1,"Router"]]};

searchIndex['persistent'] = {"items":[[0,"","persistent","A set of middleware for sharing data between requests in the Iron\nframework."],[1,"State","","Middleware for data that persists between requests with read and write capabilities."],[1,"Read","","Middleware for data that persists between Requests with read-only capabilities."],[1,"Write","","Middleware for data that persists between Requests for data which mostly\nneeds to be written instead of read."],[10,"clone","","",0],[10,"clone","","",1],[10,"clone","","",2],[10,"eval","","",1],[10,"eval","","",0],[10,"eval","","",2],[10,"before","","",1],[10,"after","","",1],[10,"before","","",0],[10,"after","","",0],[10,"before","","",2],[10,"after","","",2],[10,"both","","Construct a new pair of `State` that can be passed directly to `Chain::link`.",1],[10,"one","","Construct a new `State` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",1],[10,"both","","Construct a new pair of `Read` that can be passed directly to `Chain::link`.",0],[10,"one","","Construct a new `Read` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",0],[10,"both","","Construct a new pair of `Write` that can be passed directly to `Chain::link`.",2],[10,"one","","Construct a new `Write` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",2]],"paths":[[1,"Read"],[1,"State"],[1,"Write"]]};

searchIndex['urlencoded'] = {"items":[[0,"","urlencoded","URL Encoded Plugin for Iron."],[1,"UrlEncodedQuery","","Plugin for `Request` that extracts URL encoded data from the URL query string."],[1,"UrlEncodedBody","","Plugin for `Request` that extracts URL encoded data from the request body."],[4,"QueryMap","","Hashmap mapping strings to vectors of strings."],[10,"eval","","",0],[10,"eval","","",1]],"paths":[[1,"UrlEncodedQuery"],[1,"UrlEncodedBody"]]};

searchIndex['bodyparser'] = {"items":[[0,"","bodyparser","Body Parser Plugin for Iron"],[1,"BodyParser","",""],[10,"clone","","",0],[10,"eval","","",0]],"paths":[[1,"BodyParser"]]};

initSearch(searchIndex);

var searchIndex = {};
searchIndex['iron'] = {"items":[[0,"","iron","The main crate for the Iron library."],[1,"Request","","The `Request` given to all `Middleware`."],[11,"url","","The requested URL.",0],[11,"remote_addr","","The originating address of the request.",0],[11,"headers","","The request headers.",0],[11,"body","","The request body.",0],[11,"method","","The request method.",0],[11,"extensions","","Extensible storage for data passed between middleware.",0],[1,"Url","","HTTP/HTTPS URL type for Iron."],[11,"scheme","","The lower-cased scheme of the URL, typically \"http\" or \"https\".",1],[11,"host","","The host field of the URL, probably a domain.",1],[11,"port","","The connection port.",1],[11,"path","","The URL path, the resource to be accessed.",1],[11,"username","","The URL username field, from the userinfo section of the URL.",1],[11,"password","","The URL password field, from the userinfo section of the URL.",1],[11,"query","","The URL query string.",1],[11,"fragment","","The URL fragment.",1],[1,"Response","","The response representation given to `Middleware`"],[11,"body","","The body of the response.",2],[11,"headers","","The headers of the response.",2],[11,"status","","The response status-code.",2],[11,"extensions","","A TypeMap to be used as an extensible storage for data\nassociated with this Response.",2],[1,"Iron","","The primary entrance point to `Iron`, a `struct` to instantiate a new server."],[11,"handler","","Iron contains a `Handler`, which it uses to create responses for client\nrequests.",3],[0,"typemap","","Re-exports from the TypeMap crate."],[10,"new","typemap","Create a new, empty TypeMap.",4],[10,"insert","","Insert a value into the map with a specified key type.",4],[10,"find","","Find a value in the map and get a reference to it.",4],[10,"find_mut","","Find a value in the map and get a mutable reference to it.",4],[10,"contains","","Check if a key has an associated value stored in the map.",4],[10,"remove","","Remove a value from the map.",4],[10,"entry","","Get the given key's corresponding entry in the map for in-place manipulation.",4],[10,"data","","Read the underlying HashMap",4],[10,"data_mut","","Get a mutable reference to the underlying HashMap",4],[10,"len","","Get the number of values stored in the map.",4],[10,"is_empty","","Return true if the map contains no values.",4],[10,"clear","","Remove all entries from the map.",4],[10,"get","","Get a reference to the entry's value.",5],[10,"get_mut","","Get a mutable reference to the entry's value.",5],[10,"into_mut","","Transform the entry into a mutable reference with the same lifetime as the map.",5],[10,"set","","Set the entry's value and return the previous value.",5],[10,"take","","Move the entry's value out of the map, consuming the entry.",5],[10,"set","","Set the entry's value and return a mutable reference to it.",6],[1,"TypeMap","iron::typemap","A map keyed by types."],[6,"Assoc","","This trait defines the relationship between keys and values in a TypeMap."],[0,"middleware","iron","Iron's Middleware and Handler System"],[1,"ChainBuilder","iron::middleware","The default Chain used in Iron."],[6,"Handler","","`Handler`s are responsible for handling requests by creating Responses from Requests."],[9,"call","","Produce a `Response` from a Request, with the possibility of error.",7],[10,"catch","","If `Handler`'s call method produces an Err, then this method is called\nto produce a `Response` and possibly handle the error.",7],[6,"BeforeMiddleware","","`BeforeMiddleware` are fired before a `Handler` is called inside of a Chain."],[9,"before","","Do whatever work this middleware should do with a `Request` object.",8],[10,"catch","","Try to `catch` an error thrown by this Middleware or a previous `BeforeMiddleware`.",8],[6,"AfterMiddleware","","`AfterMiddleware` are fired after a `Handler` is called inside of a Chain."],[9,"after","","Do whatever work this middleware needs to do with both a `Request` and `Response` objects.",9],[10,"catch","","Try to catch an error thrown by previous `AfterMiddleware`, the `Handler`, or a previous\n`BeforeMiddleware`.",9],[6,"AroundMiddleware","","AroundMiddleware are used to wrap and replace the `Handler` in a `Chain`."],[9,"around","","Produce a `Handler` from this `AroundMiddleware` given another `Handler`.",10],[6,"Chain","","Chain's hold `BeforeMiddleware`, a `Handler`, and `AfterMiddleware` and are responsible\nfor correctly dispatching a `Request` through them."],[9,"new","","Create a new Chain from a `Handler`.",11],[9,"link","","Link both a before and after middleware to the chain at once.",11],[9,"link_before","","Link a `BeforeMiddleware` to the Chain.",11],[9,"link_after","","Link a `AfterMiddleware` to the Chain.",11],[9,"around","","Wrap the Chain's `Handler` using an AroundMiddleware.",11],[10,"new","","Construct a new ChainBuilder from a `Handler`.",12],[10,"new","","",12],[10,"link","","",12],[10,"link_before","","",12],[10,"link_after","","",12],[10,"around","","",12],[10,"call","","",12],[10,"catch","","",12],[10,"call","alloc::boxed","",13],[10,"catch","","",13],[10,"call","alloc::arc","",14],[10,"catch","","",14],[0,"errors","iron","Some common error types for use within Iron and in downstream middleware."],[1,"FileError","iron::errors","The standard Error implementation used to wrap IoErrors\nthat occur when reading or writing files or otherwise\ninteracting with the file system."],[10,"eq","","",15],[10,"ne","","",15],[10,"clone","","",15],[10,"fmt","","",15],[10,"new","","Create a new FileError from an IoError.",15],[10,"unwrap","","Access the original IoError.",15],[10,"name","","",15],[10,"description","","",15],[10,"clone","iron","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"parse","","Create a URL from a string.",1],[10,"from_generic_url","","Create a `Url` from a `rust-url` `Url`.",1],[10,"into_generic_url","","Create a `rust-url` `Url` from a `Url`.",1],[10,"fmt","","",1],[10,"encode","","",1],[10,"decode","","",1],[10,"fmt","","",0],[10,"from_http","","Create a request from an HttpRequest.",0],[10,"extensions","","",0],[10,"extensions_mut","","",0],[10,"load","http::server::request","Get a response from an open socket.",16],[10,"new","http::buffer","",17],[10,"poke_byte","","Poke a single byte back so it will be read next. For this to make sense, you must have just\nread that byte. If `self.pos` is 0 and `self.max` is not 0 (i.e. if the buffer is just\nfilled\nVery great caution must be used in calling this as it will fail if `self.pos` is 0.",17],[10,"read_byte","","Slightly faster implementation of read_byte than that which is provided by ReaderUtil\n(which just uses `read()`)",17],[10,"finish_response","","Finish off writing a response: this flushes the writer and in case of chunked\nTransfer-Encoding writes the ending zero-length chunk to indicate completion.",17],[10,"read","","Read at most N bytes into `buf`, where N is the minimum of `buf.len()` and the buffer size.",17],[10,"read_at_least","","",17],[10,"read_byte","","",17],[10,"push","","",17],[10,"push_at_least","","",17],[10,"read_exact","","",17],[10,"read_to_end","","",17],[10,"read_to_string","","",17],[10,"read_le_uint_n","","",17],[10,"read_le_int_n","","",17],[10,"read_be_uint_n","","",17],[10,"read_be_int_n","","",17],[10,"read_le_uint","","",17],[10,"read_le_int","","",17],[10,"read_be_uint","","",17],[10,"read_be_int","","",17],[10,"read_be_u64","","",17],[10,"read_be_u32","","",17],[10,"read_be_u16","","",17],[10,"read_be_i64","","",17],[10,"read_be_i32","","",17],[10,"read_be_i16","","",17],[10,"read_be_f64","","",17],[10,"read_be_f32","","",17],[10,"read_le_u64","","",17],[10,"read_le_u32","","",17],[10,"read_le_u16","","",17],[10,"read_le_i64","","",17],[10,"read_le_i32","","",17],[10,"read_le_i16","","",17],[10,"read_le_f64","","",17],[10,"read_le_f32","","",17],[10,"read_u8","","",17],[10,"read_i8","","",17],[10,"write","","",17],[10,"flush","","",17],[10,"flush","","",17],[10,"write_fmt","","",17],[10,"write_str","","",17],[10,"write_line","","",17],[10,"write_char","","",17],[10,"write_int","","",17],[10,"write_uint","","",17],[10,"write_le_uint","","",17],[10,"write_le_int","","",17],[10,"write_be_uint","","",17],[10,"write_be_int","","",17],[10,"write_be_u64","","",17],[10,"write_be_u32","","",17],[10,"write_be_u16","","",17],[10,"write_be_i64","","",17],[10,"write_be_i32","","",17],[10,"write_be_i16","","",17],[10,"write_be_f64","","",17],[10,"write_be_f32","","",17],[10,"write_le_u64","","",17],[10,"write_le_u32","","",17],[10,"write_le_u16","","",17],[10,"write_le_i64","","",17],[10,"write_le_i32","","",17],[10,"write_le_i16","","",17],[10,"write_le_f64","","",17],[10,"write_le_f32","","",17],[10,"write_u8","","",17],[10,"write_i8","","",17],[10,"new","http::client::request","Create a `RequestWriter` writing to the specified location",18],[10,"new_request","","",18],[10,"try_connect","","Connect to the remote host if not already connected.",18],[10,"connect","","Connect to the remote host; fails if already connected.\nReturns ``true`` upon success and ``false`` upon failure (also use conditions).",18],[10,"try_write_headers","","Write the Request-Line and headers of the response, if we have not already done so.",18],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",18],[10,"read_response","","Send the request and construct a `ResponseReader` out of it.",18],[10,"write","","",18],[10,"flush","","",18],[10,"flush","","",18],[10,"write_fmt","","",18],[10,"write_str","","",18],[10,"write_line","","",18],[10,"write_char","","",18],[10,"write_int","","",18],[10,"write_uint","","",18],[10,"write_le_uint","","",18],[10,"write_le_int","","",18],[10,"write_be_uint","","",18],[10,"write_be_int","","",18],[10,"write_be_u64","","",18],[10,"write_be_u32","","",18],[10,"write_be_u16","","",18],[10,"write_be_i64","","",18],[10,"write_be_i32","","",18],[10,"write_be_i16","","",18],[10,"write_be_f64","","",18],[10,"write_be_f32","","",18],[10,"write_le_u64","","",18],[10,"write_le_u32","","",18],[10,"write_le_u16","","",18],[10,"write_le_i64","","",18],[10,"write_le_i32","","",18],[10,"write_le_i16","","",18],[10,"write_le_f64","","",18],[10,"write_le_f32","","",18],[10,"write_u8","","",18],[10,"write_i8","","",18],[10,"construct","http::client::response","",19],[10,"read","","",19],[10,"read_at_least","","",19],[10,"read_byte","","",19],[10,"push","","",19],[10,"push_at_least","","",19],[10,"read_exact","","",19],[10,"read_to_end","","",19],[10,"read_to_string","","",19],[10,"read_le_uint_n","","",19],[10,"read_le_int_n","","",19],[10,"read_be_uint_n","","",19],[10,"read_be_int_n","","",19],[10,"read_le_uint","","",19],[10,"read_le_int","","",19],[10,"read_be_uint","","",19],[10,"read_be_int","","",19],[10,"read_be_u64","","",19],[10,"read_be_u32","","",19],[10,"read_be_u16","","",19],[10,"read_be_i64","","",19],[10,"read_be_i32","","",19],[10,"read_be_i16","","",19],[10,"read_be_f64","","",19],[10,"read_be_f32","","",19],[10,"read_le_u64","","",19],[10,"read_le_u32","","",19],[10,"read_le_u16","","",19],[10,"read_le_i64","","",19],[10,"read_le_i32","","",19],[10,"read_le_i16","","",19],[10,"read_le_f64","","",19],[10,"read_le_f32","","",19],[10,"read_u8","","",19],[10,"read_i8","","",19],[10,"connect","http::client::sslclients::openssl","",20],[10,"read","","",20],[10,"read_at_least","","",20],[10,"read_byte","","",20],[10,"push","","",20],[10,"push_at_least","","",20],[10,"read_exact","","",20],[10,"read_to_end","","",20],[10,"read_to_string","","",20],[10,"read_le_uint_n","","",20],[10,"read_le_int_n","","",20],[10,"read_be_uint_n","","",20],[10,"read_be_int_n","","",20],[10,"read_le_uint","","",20],[10,"read_le_int","","",20],[10,"read_be_uint","","",20],[10,"read_be_int","","",20],[10,"read_be_u64","","",20],[10,"read_be_u32","","",20],[10,"read_be_u16","","",20],[10,"read_be_i64","","",20],[10,"read_be_i32","","",20],[10,"read_be_i16","","",20],[10,"read_be_f64","","",20],[10,"read_be_f32","","",20],[10,"read_le_u64","","",20],[10,"read_le_u32","","",20],[10,"read_le_u16","","",20],[10,"read_le_i64","","",20],[10,"read_le_i32","","",20],[10,"read_le_i16","","",20],[10,"read_le_f64","","",20],[10,"read_le_f32","","",20],[10,"read_u8","","",20],[10,"read_i8","","",20],[10,"write","","",20],[10,"flush","","",20],[10,"flush","","",20],[10,"write_fmt","","",20],[10,"write_str","","",20],[10,"write_line","","",20],[10,"write_char","","",20],[10,"write_int","","",20],[10,"write_uint","","",20],[10,"write_le_uint","","",20],[10,"write_le_int","","",20],[10,"write_be_uint","","",20],[10,"write_be_int","","",20],[10,"write_be_u64","","",20],[10,"write_be_u32","","",20],[10,"write_be_u16","","",20],[10,"write_be_i64","","",20],[10,"write_be_i32","","",20],[10,"write_be_i16","","",20],[10,"write_be_f64","","",20],[10,"write_be_f32","","",20],[10,"write_le_u64","","",20],[10,"write_le_u32","","",20],[10,"write_le_u16","","",20],[10,"write_le_i64","","",20],[10,"write_le_i32","","",20],[10,"write_le_i16","","",20],[10,"write_le_f64","","",20],[10,"write_le_f32","","",20],[10,"write_u8","","",20],[10,"write_i8","","",20],[10,"new","http::server::request","",21],[10,"read_request_line","","",21],[10,"read_header","","Read a header (name, value) pair.",21],[10,"read","","",21],[10,"read_at_least","","",21],[10,"read_byte","","",21],[10,"push","","",21],[10,"push_at_least","","",21],[10,"read_exact","","",21],[10,"read_to_end","","",21],[10,"read_to_string","","",21],[10,"read_le_uint_n","","",21],[10,"read_le_int_n","","",21],[10,"read_be_uint_n","","",21],[10,"read_be_int_n","","",21],[10,"read_le_uint","","",21],[10,"read_le_int","","",21],[10,"read_be_uint","","",21],[10,"read_be_int","","",21],[10,"read_be_u64","","",21],[10,"read_be_u32","","",21],[10,"read_be_u16","","",21],[10,"read_be_i64","","",21],[10,"read_be_i32","","",21],[10,"read_be_i16","","",21],[10,"read_be_f64","","",21],[10,"read_be_f32","","",21],[10,"read_le_u64","","",21],[10,"read_le_u32","","",21],[10,"read_le_u16","","",21],[10,"read_le_i64","","",21],[10,"read_le_i32","","",21],[10,"read_le_i16","","",21],[10,"read_le_f64","","",21],[10,"read_le_f32","","",21],[10,"read_u8","","",21],[10,"read_i8","","",21],[10,"assert_receiver_is_total_eq","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"ne","","",22],[10,"fmt","","",22],[10,"new","http::server::response","Create a `ResponseWriter` writing to the specified location",23],[10,"write_content_auto","","Write a response with the specified Content-Type and content; the Content-Length header is\nset based upon the contents",23],[10,"try_write_headers","","Write the Status-Line and headers of the response, if we have not already done so.",23],[10,"write_headers","","Write the Status-Line and headers of the response, in preparation for writing the body.",23],[10,"finish_response","","",23],[10,"write","","",23],[10,"flush","","",23],[10,"flush","","",23],[10,"write_fmt","","",23],[10,"write_str","","",23],[10,"write_line","","",23],[10,"write_char","","",23],[10,"write_int","","",23],[10,"write_uint","","",23],[10,"write_le_uint","","",23],[10,"write_le_int","","",23],[10,"write_be_uint","","",23],[10,"write_be_int","","",23],[10,"write_be_u64","","",23],[10,"write_be_u32","","",23],[10,"write_be_u16","","",23],[10,"write_be_i64","","",23],[10,"write_be_i32","","",23],[10,"write_be_i16","","",23],[10,"write_be_f64","","",23],[10,"write_be_f32","","",23],[10,"write_le_u64","","",23],[10,"write_le_u32","","",23],[10,"write_le_u16","","",23],[10,"write_le_i64","","",23],[10,"write_le_i32","","",23],[10,"write_le_i16","","",23],[10,"write_le_f64","","",23],[10,"write_le_f32","","",23],[10,"write_u8","","",23],[10,"write_i8","","",23],[10,"hash","http::method","",24],[10,"clone","","",24],[10,"clone_from","","",24],[10,"assert_receiver_is_total_eq","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"ne","","",24],[10,"from_str","","Get a *known* `Method` from an *ASCII* string, regardless of case.",24],[10,"fmt","","",24],[10,"from_str_or_new","","Get a `Method` from an *ASCII* string.",24],[10,"assert_receiver_is_total_eq","http::headers::accept_ranges","",25],[10,"eq","","",25],[10,"ne","","",25],[10,"ne","","",25],[10,"clone","","",25],[10,"clone_from","","",25],[10,"assert_receiver_is_total_eq","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"clone_from","","",26],[10,"from_stream","","",26],[10,"to_stream","","",26],[10,"http_value","","",26],[10,"to_stream","","",26],[10,"assert_receiver_is_total_eq","http::headers::connection","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"clone_from","","",27],[10,"fmt","","",27],[10,"from_stream","","",27],[10,"to_stream","","",27],[10,"http_value","","",27],[10,"to_stream","","",27],[10,"assert_receiver_is_total_eq","http::headers::content_type","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"ne","","",28],[10,"clone","","",28],[10,"clone_from","","",28],[10,"new","","",28],[10,"fmt","","",28],[10,"from_stream","","",28],[10,"to_stream","","",28],[10,"http_value","","",28],[10,"to_stream","","",28],[10,"assert_receiver_is_total_eq","http::headers::etag","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"ne","","",29],[10,"clone","","",29],[10,"clone_from","","",29],[10,"fmt","","",29],[10,"from_stream","","",29],[10,"to_stream","","",29],[10,"http_value","","",29],[10,"to_stream","","",29],[10,"assert_receiver_is_total_eq","http::headers::host","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"ne","","",30],[10,"clone","","",30],[10,"clone_from","","",30],[10,"fmt","","",30],[10,"from_stream","","",30],[10,"http_value","","",30],[10,"to_stream","","",30],[10,"assert_receiver_is_total_eq","http::headers::transfer_encoding","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"ne","","",31],[10,"clone","","",31],[10,"clone_from","","",31],[10,"from_stream","","",31],[10,"to_stream","","",31],[10,"http_value","","",31],[10,"to_stream","","",31],[10,"assert_receiver_is_total_eq","http::headers","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"ne","","",32],[10,"clone","","",32],[10,"clone_from","","",32],[10,"assert_receiver_is_total_eq","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"ne","","",33],[10,"new","","",34],[10,"verify_consumed","","Check that the entire header value has been consumed.",34],[10,"some_if_consumed","","Turn a constructed header value into an Option: Some(value) if the header value is consumed\nor None if it is not, thus indicating: \"I'm finished and expect nothing more. Anything more\nis an error.\"",34],[10,"consume_optional_lws","","Consume optional `*LWS`. That is, zero or more of SP and HT, until it\ngets to something other than SP and HT or gets to the end of the header.",34],[10,"consume_lws","","Consume `1*LWS`. That is, one or more of SP and HT, until it gets to\nsomething other than SP and HT or gets to the end of the header.",34],[10,"consume_comma_lws","","Return values:\n- CommaConsumed if there was a comma and it was consumed;\n- EndOfValue if the header value has been completely consumed;\n- ErrCommaNotFound if the next thing wasn't a comma (this is an error state)",34],[10,"read_quoted_string","","Read a quoted-string from the current position.\nIf the quoted-string is not begun immediately or the header ends before it is completed,\nthen None is returned; TODO: decide if I can return the bytes read (at present, escapes and\ndouble quote would be lost if I did that).",34],[10,"read_token_or_quoted_string","","Read a token (RFC 2616 definition) from the header value.",34],[10,"read_token","","Read a token (RFC 2616 definition) from the header value.",34],[10,"next","","",34],[10,"size_hint","","",34],[10,"chain","","",34],[10,"zip","","",34],[10,"map","","",34],[10,"filter","","",34],[10,"filter_map","","",34],[10,"enumerate","","",34],[10,"peekable","","",34],[10,"skip_while","","",34],[10,"take_while","","",34],[10,"skip","","",34],[10,"take","","",34],[10,"scan","","",34],[10,"flat_map","","",34],[10,"fuse","","",34],[10,"inspect","","",34],[10,"by_ref","","",34],[10,"collect","","",34],[10,"nth","","",34],[10,"last","","",34],[10,"fold","","",34],[10,"count","","",34],[10,"all","","",34],[10,"any","","",34],[10,"find","","",34],[10,"position","","",34],[10,"max_by","","",34],[10,"min_by","","",34],[10,"from_stream","collections::vec","",35],[10,"to_stream","","",35],[10,"http_value","","",35],[10,"to_stream","","",35],[10,"from_stream","collections::string","",36],[10,"to_stream","","",36],[10,"http_value","","",36],[10,"to_stream","","",36],[10,"from_stream","url","",37],[10,"http_value","","",37],[10,"to_stream","","",37],[10,"from_stream","http::method","",24],[10,"http_value","","",24],[10,"to_stream","","",24],[10,"from_stream","time","",38],[10,"http_value","","",38],[10,"to_stream","","",38],[10,"clone","http::headers::request","",39],[10,"clone_from","","",39],[10,"new","","",39],[10,"insert","","Consume a header, putting it into this structure.",39],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",39],[10,"iter","","",39],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",39],[10,"next","","",40],[10,"size_hint","","",40],[10,"chain","","",40],[10,"zip","","",40],[10,"map","","",40],[10,"filter","","",40],[10,"filter_map","","",40],[10,"enumerate","","",40],[10,"peekable","","",40],[10,"skip_while","","",40],[10,"take_while","","",40],[10,"skip","","",40],[10,"take","","",40],[10,"scan","","",40],[10,"flat_map","","",40],[10,"fuse","","",40],[10,"inspect","","",40],[10,"by_ref","","",40],[10,"collect","","",40],[10,"nth","","",40],[10,"last","","",40],[10,"fold","","",40],[10,"count","","",40],[10,"all","","",40],[10,"any","","",40],[10,"find","","",40],[10,"position","","",40],[10,"max_by","","",40],[10,"min_by","","",40],[10,"header_name","","",41],[10,"header_value","","",41],[10,"write_header","","",41],[10,"value_from_stream","","",41],[10,"clone","http::headers::response","",42],[10,"clone_from","","",42],[10,"new","","",42],[10,"insert","","Consume a header, putting it into this structure.",42],[10,"insert_raw","","Insert a raw header into the collection.\nThis will return an error if the value is not valid UTF-8 or if the name is that\nof a strongly-typed header and the value is not a valid value for that header.",42],[10,"iter","","",42],[10,"write_all","","Write all the headers to a writer. This includes an extra \\r\\n at the end to\nsignal end of headers.",42],[10,"next","","",43],[10,"size_hint","","",43],[10,"chain","","",43],[10,"zip","","",43],[10,"map","","",43],[10,"filter","","",43],[10,"filter_map","","",43],[10,"enumerate","","",43],[10,"peekable","","",43],[10,"skip_while","","",43],[10,"take_while","","",43],[10,"skip","","",43],[10,"take","","",43],[10,"scan","","",43],[10,"flat_map","","",43],[10,"fuse","","",43],[10,"inspect","","",43],[10,"by_ref","","",43],[10,"collect","","",43],[10,"nth","","",43],[10,"last","","",43],[10,"fold","","",43],[10,"count","","",43],[10,"all","","",43],[10,"any","","",43],[10,"find","","",43],[10,"position","","",43],[10,"max_by","","",43],[10,"min_by","","",43],[10,"header_name","","",44],[10,"header_value","","",44],[10,"write_header","","",44],[10,"value_from_stream","","",44],[10,"fmt","http::rfc2616::content_coding","",45],[10,"from_str","","",45],[10,"fmt","http::rfc2616::transfer_coding","",46],[10,"clone","http::status","",47],[10,"clone_from","","",47],[10,"eq","","",47],[10,"ne","","",47],[10,"ne","","",47],[10,"assert_receiver_is_total_eq","","",47],[10,"code","","Get the status code",47],[10,"reason","","Get the reason phrase",47],[10,"from_code_and_reason","","Get a status from the code and reason",47],[10,"fmt","","",47],[10,"fmt","","",47],[10,"to_i64","","Equivalent to `Some(self.code() as i64)`",47],[10,"to_u64","","Equivalent to `Some(self.code() as u64)`",47],[10,"to_int","","",47],[10,"to_i8","","",47],[10,"to_i16","","",47],[10,"to_i32","","",47],[10,"to_uint","","",47],[10,"to_u8","","",47],[10,"to_u16","","",47],[10,"to_u32","","",47],[10,"to_f32","","",47],[10,"to_f64","","",47],[10,"from_i64","","Get a *registered* status code from the number of its status code.",47],[10,"from_u64","","Get a *registered* status code from the number of its status code.",47],[10,"from_int","","",47],[10,"from_i8","","",47],[10,"from_i16","","",47],[10,"from_i32","","",47],[10,"from_uint","","",47],[10,"from_u8","","",47],[10,"from_u16","","",47],[10,"from_u32","","",47],[10,"from_f32","","",47],[10,"from_f64","","",47],[10,"new","iron","Construct a blank Response",2],[10,"status","","Create a new response with the status.",2],[10,"with","","Create a new response with the specified body and status.",2],[10,"redirect","","Create a new Response with the `location` header set to the specified url.",2],[10,"from_file","","Create a response from a file on disk.",2],[10,"fmt","","",2],[10,"extensions","","",2],[10,"extensions_mut","","",2],[10,"listen","","Kick off the server process.",3],[10,"new","","Instantiate a new instance of `Iron`.",3],[4,"IronError","",""],[4,"IronResult","",""],[1,"TypeMap","","A map keyed by types."],[0,"status","",""],[2,"Status","iron::status","HTTP status code"],[12,"Continue","","",47],[12,"SwitchingProtocols","","",47],[12,"Processing","","",47],[12,"Ok","","",47],[12,"Created","","",47],[12,"Accepted","","",47],[12,"NonAuthoritativeInformation","","",47],[12,"NoContent","","",47],[12,"ResetContent","","",47],[12,"PartialContent","","",47],[12,"MultiStatus","","",47],[12,"AlreadyReported","","",47],[12,"ImUsed","","",47],[12,"MultipleChoices","","",47],[12,"MovedPermanently","","",47],[12,"Found","","",47],[12,"SeeOther","","",47],[12,"NotModified","","",47],[12,"UseProxy","","",47],[12,"SwitchProxy","","",47],[12,"TemporaryRedirect","","",47],[12,"PermanentRedirect","","",47],[12,"BadRequest","","",47],[12,"Unauthorized","","",47],[12,"PaymentRequired","","",47],[12,"Forbidden","","",47],[12,"NotFound","","",47],[12,"MethodNotAllowed","","",47],[12,"NotAcceptable","","",47],[12,"ProxyAuthenticationRequired","","",47],[12,"RequestTimeout","","",47],[12,"Conflict","","",47],[12,"Gone","","",47],[12,"LengthRequired","","",47],[12,"PreconditionFailed","","",47],[12,"RequestEntityTooLarge","","",47],[12,"RequestUriTooLong","","",47],[12,"UnsupportedMediaType","","",47],[12,"RequestedRangeNotSatisfiable","","",47],[12,"ExpectationFailed","","",47],[12,"ImATeapot","","",47],[12,"AuthenticationTimeout","","",47],[12,"UnprocessableEntity","","",47],[12,"Locked","","",47],[12,"FailedDependency","","",47],[12,"MethodFailure","","",47],[12,"UnorderedCollection","","",47],[12,"UpgradeRequired","","",47],[12,"PreconditionRequired","","",47],[12,"TooManyRequests","","",47],[12,"RequestHeaderFieldsTooLarge","","",47],[12,"UnavailableForLegalReasons","","",47],[12,"InternalServerError","","",47],[12,"NotImplemented","","",47],[12,"BadGateway","","",47],[12,"ServiceUnavailable","","",47],[12,"GatewayTimeout","","",47],[12,"HttpVersionNotSupported","","",47],[12,"VariantAlsoNegotiates","","",47],[12,"InsufficientStorage","","",47],[12,"LoopDetected","","",47],[12,"NotExtended","","",47],[12,"NetworkAuthenticationRequired","","",47],[12,"UnregisteredStatus","","",47],[0,"method","iron",""],[2,"Method","iron::method","HTTP methods, as defined in RFC 2616, §5.1.1."],[12,"Options","","",24],[12,"Get","","",24],[12,"Head","","",24],[12,"Post","","",24],[12,"Put","","",24],[12,"Delete","","",24],[12,"Trace","","",24],[12,"Connect","","",24],[12,"Patch","","",24],[12,"ExtensionMethod","","",24],[0,"headers","iron","Types and utilities for working with headers in HTTP requests and responses."],[2,"HeaderLineErr","iron::headers",""],[12,"EndOfFile","","",48],[12,"EndOfHeaders","","",48],[12,"MalformedHeaderValue","","",48],[12,"MalformedHeaderSyntax","","",48],[0,"test_utils","",""],[3,"from_stream_with_str","iron::headers::test_utils",""],[3,"to_stream_into_str","",""],[3,"assert_invalid","",""],[3,"assert_conversion_correct","",""],[3,"assert_interpretation_correct","",""],[0,"serialization_utils","iron::headers","Utility functions for assisting with conversion of headers from and to the HTTP text form."],[3,"normalise_header_name","iron::headers::serialization_utils","Normalise an HTTP header name."],[3,"comma_split","","Split a value on commas, as is common for HTTP headers."],[3,"comma_split_iter","",""],[6,"WriterUtil","",""],[9,"write_maybe_quoted_string","","",49],[9,"write_quoted_string","","",49],[9,"write_parameter","","",49],[9,"write_parameters","","",49],[9,"write_quality","","",49],[9,"write_token","","",49],[3,"comma_join","","Join a vector of values with commas, as is common for HTTP headers."],[3,"push_maybe_quoted_string","","Push a ( token | quoted-string ) onto a string and return it again"],[3,"maybe_quoted_string","","Make a string into a ( token | quoted-string ), preferring a token"],[3,"push_quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"quoted_string","","Quote a string, to turn it into an RFC 2616 quoted-string"],[3,"unquote_string","","Parse a quoted-string. Returns ``None`` if the string is not a valid quoted-string."],[3,"maybe_unquote_string","","Parse a ( token | quoted-string ). Returns ``None`` if it is not valid."],[3,"push_parameter","",""],[3,"push_parameters","",""],[0,"accept_ranges","iron::headers","The Accept-Ranges request header, defined in RFC 2616, Section 14.5."],[2,"RangeUnit","iron::headers::accept_ranges",""],[12,"Bytes","","",25],[12,"OtherRangeUnit","","",25],[2,"AcceptableRanges","",""],[12,"RangeUnits","","",26],[12,"NoAcceptableRanges","","",26],[0,"connection","iron::headers","The Connection general header, defined in RFC 2616, Section 14.10."],[2,"Connection","iron::headers::connection","A value for the Connection header. Note that should it be a ``Token``, the string is in\nnormalised header case (e.g. \"Keep-Alive\")."],[12,"Token","","",27],[12,"Close","","",27],[0,"content_type","iron::headers","The Content-Type entity header, defined in RFC 2616, Section 14.17."],[1,"MediaType","iron::headers::content_type",""],[11,"type_","","",28],[11,"subtype","","",28],[11,"parameters","","",28],[0,"etag","iron::headers",""],[1,"EntityTag","iron::headers::etag",""],[11,"weak","","",29],[11,"opaque_tag","","",29],[3,"weak_etag","",""],[3,"strong_etag","",""],[0,"host","iron::headers","The Host request header, defined in RFC 2616, Section 14.23."],[1,"Host","iron::headers::host","A simple little thing for the host of a request"],[11,"name","","The name of the host that was requested",30],[11,"port","","If unspecified, assume the default port was used (80 for HTTP, 443 for HTTPS).\nIn that case, you shouldn't need to worry about it in URLs that you build, provided you\ninclude the scheme.",30],[0,"transfer_encoding","iron::headers","The Transfer-Encoding request header, defined in RFC 2616, sections 14.41 and 3.6."],[2,"TransferCoding","iron::headers::transfer_encoding","RFC 2616, section 3.6:"],[12,"Chunked","","",31],[12,"TransferExtension","","",31],[4,"DeltaSeconds","iron::headers",""],[2,"ConsumeCommaLWSResult","",""],[12,"CommaConsumed","","",32],[12,"EndOfValue","","",32],[12,"ErrCommaNotFound","","",32],[6,"HeaderEnum","",""],[9,"header_name","","",50],[9,"header_value","","",50],[9,"write_header","","",50],[9,"value_from_stream","","Return values:",50],[3,"header_enum_from_stream","","Shifted out of being a default method to fix an ICE (not yet reported, TODO)"],[1,"HeaderValueByteIterator","","An iterator over the bytes of a header value.\nThis ensures one cannot read past the end of a header mistakenly and that linear white space is\nhandled correctly so that nothing else needs to worry about it. Any linear whitespace (multiple\nspaces outside of a quoted-string) is compacted into a single SP."],[11,"reader","","",34],[11,"next_byte","","This field serves two purposes. *During* iteration, it will typically be ``None``, but\ncertain cases will cause it to be a ``Some``, meaning that the next ``next()`` call will\nreturn that value rather than reading a new byte. At the *end* of iteration (after\n``next()`` has returned ``None``), it will be the extra byte which it has had to consume\nfrom the stream because of the possibility of linear white space of the form ``CR LF SP``.\nIt is guaranteed that if ``self.state == Finished`` this will be a ``Some``.",34],[11,"at_start","","",34],[6,"HeaderConvertible","","A datatype for headers."],[9,"from_stream","","Read a header value from an iterator over the raw value.",51],[9,"to_stream","","Write the HTTP value of the header to the stream.",51],[9,"http_value","","The value of the header as it would be written for an HTTP header.",51],[6,"CommaListHeaderConvertible","","A header with multiple comma-separated values. Implement this and a HeaderConvertible\nimplementation for Vec<T> is yours for free—just make sure your reading does not consume the\ncomma."],[0,"request","",""],[2,"Header","iron::headers::request",""],[12,"CacheControl","","",41],[12,"Connection","","",41],[12,"Date","","",41],[12,"Pragma","","",41],[12,"Trailer","","",41],[12,"TransferEncoding","","",41],[12,"Upgrade","","",41],[12,"Via","","",41],[12,"Warning","","",41],[12,"Accept","","",41],[12,"AcceptCharset","","",41],[12,"AcceptEncoding","","",41],[12,"AcceptLanguage","","",41],[12,"Authorization","","",41],[12,"Expect","","",41],[12,"From","","",41],[12,"Host","","",41],[12,"IfMatch","","",41],[12,"IfModifiedSince","","",41],[12,"IfNoneMatch","","",41],[12,"IfRange","","",41],[12,"IfUnmodifiedSince","","",41],[12,"MaxForwards","","",41],[12,"ProxyAuthorization","","",41],[12,"Range","","",41],[12,"Referer","","",41],[12,"Te","","",41],[12,"UserAgent","","",41],[12,"Allow","","",41],[12,"ContentEncoding","","",41],[12,"ContentLanguage","","",41],[12,"ContentLength","","",41],[12,"ContentLocation","","",41],[12,"ContentMd5","","",41],[12,"ContentRange","","",41],[12,"ContentType","","",41],[12,"Expires","","",41],[12,"LastModified","","",41],[12,"ExtensionHeader","","",41],[1,"HeaderCollection","",""],[11,"cache_control","","",39],[11,"connection","","",39],[11,"date","","",39],[11,"pragma","","",39],[11,"trailer","","",39],[11,"transfer_encoding","","",39],[11,"upgrade","","",39],[11,"via","","",39],[11,"warning","","",39],[11,"accept","","",39],[11,"accept_charset","","",39],[11,"accept_encoding","","",39],[11,"accept_language","","",39],[11,"authorization","","",39],[11,"expect","","",39],[11,"from","","",39],[11,"host","","",39],[11,"if_match","","",39],[11,"if_modified_since","","",39],[11,"if_none_match","","",39],[11,"if_range","","",39],[11,"if_unmodified_since","","",39],[11,"max_forwards","","",39],[11,"proxy_authorization","","",39],[11,"range","","",39],[11,"referer","","",39],[11,"te","","",39],[11,"user_agent","","",39],[11,"allow","","",39],[11,"content_encoding","","",39],[11,"content_language","","",39],[11,"content_length","","",39],[11,"content_location","","",39],[11,"content_md5","","",39],[11,"content_range","","",39],[11,"content_type","","",39],[11,"expires","","",39],[11,"last_modified","","",39],[11,"extensions","","",39],[1,"HeaderCollectionIterator","",""],[0,"response","iron::headers",""],[2,"Header","iron::headers::response",""],[12,"CacheControl","","",44],[12,"Connection","","",44],[12,"Date","","",44],[12,"Pragma","","",44],[12,"Trailer","","",44],[12,"TransferEncoding","","",44],[12,"Upgrade","","",44],[12,"Via","","",44],[12,"Warning","","",44],[12,"AcceptPatch","","",44],[12,"AcceptRanges","","",44],[12,"Age","","",44],[12,"ETag","","",44],[12,"Location","","",44],[12,"ProxyAuthenticate","","",44],[12,"RetryAfter","","",44],[12,"Server","","",44],[12,"Vary","","",44],[12,"WwwAuthenticate","","",44],[12,"Allow","","",44],[12,"ContentEncoding","","",44],[12,"ContentLanguage","","",44],[12,"ContentLength","","",44],[12,"ContentLocation","","",44],[12,"ContentMd5","","",44],[12,"ContentRange","","",44],[12,"ContentType","","",44],[12,"Expires","","",44],[12,"LastModified","","",44],[12,"ExtensionHeader","","",44],[1,"HeaderCollection","",""],[11,"cache_control","","",42],[11,"connection","","",42],[11,"date","","",42],[11,"pragma","","",42],[11,"trailer","","",42],[11,"transfer_encoding","","",42],[11,"upgrade","","",42],[11,"via","","",42],[11,"warning","","",42],[11,"accept_patch","","",42],[11,"accept_ranges","","",42],[11,"age","","",42],[11,"etag","","",42],[11,"location","","",42],[11,"proxy_authenticate","","",42],[11,"retry_after","","",42],[11,"server","","",42],[11,"vary","","",42],[11,"www_authenticate","","",42],[11,"allow","","",42],[11,"content_encoding","","",42],[11,"content_language","","",42],[11,"content_length","","",42],[11,"content_location","","",42],[11,"content_md5","","",42],[11,"content_range","","",42],[11,"content_type","","",42],[11,"expires","","",42],[11,"last_modified","","",42],[11,"extensions","","",42],[1,"HeaderCollectionIterator","",""],[6,"Plugin","iron","An interface for plugins that cache values between calls."],[9,"get","","Return a copy of the plugin's produced value.",52],[9,"get_ref","","Return a reference to the plugin's produced value.",52],[9,"get_mut","","Return a mutable reference to the plugin's produced value.",52],[6,"Error","",""],[9,"name","","",53],[9,"description","","",53],[9,"cause","","",53],[6,"ErrorRefExt","",""],[9,"is","","",54],[9,"downcast","","",54]],"paths":[[1,"Request"],[1,"Url"],[1,"Response"],[1,"Iron"],[1,"TypeMap"],[1,"OccupiedEntry"],[1,"VacantEntry"],[6,"Handler"],[6,"BeforeMiddleware"],[6,"AfterMiddleware"],[6,"AroundMiddleware"],[6,"Chain"],[1,"ChainBuilder"],[1,"Box"],[1,"Arc"],[1,"FileError"],[1,"Request"],[1,"BufferedStream"],[1,"RequestWriter"],[1,"ResponseReader"],[2,"NetworkStream"],[1,"RequestBuffer"],[2,"RequestUri"],[1,"ResponseWriter"],[2,"Method"],[2,"RangeUnit"],[2,"AcceptableRanges"],[2,"Connection"],[1,"MediaType"],[1,"EntityTag"],[1,"Host"],[2,"TransferCoding"],[2,"ConsumeCommaLWSResult"],[2,"HeaderValueByteIteratorState"],[1,"HeaderValueByteIterator"],[1,"Vec"],[1,"String"],[1,"Url"],[1,"Tm"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[1,"HeaderCollection"],[1,"HeaderCollectionIterator"],[2,"Header"],[2,"ValueToken"],[2,"ValueToken"],[2,"Status"],[2,"HeaderLineErr"],[6,"WriterUtil"],[6,"HeaderEnum"],[6,"HeaderConvertible"],[6,"Plugin"],[6,"Error"],[6,"ErrorRefExt"]]};
searchIndex['router'] = {"items":[[0,"","router","`Router` provides a fast router handler for the Iron web framework."],[1,"Router","","`Router` provides an interface for creating complex routes as middleware\nfor the Iron framework."],[10,"new","","`new` constructs a new, blank `Router`.",0],[10,"route","","Add a new route to a `Router`, matching both a method and glob pattern.",0],[10,"get","","Like route, but specialized to the `Get` method.",0],[10,"post","","Like route, but specialized to the `Post` method.",0],[10,"put","","Like route, but specialized to the `Put` method.",0],[10,"delete","","Like route, but specialized to the `Delete` method.",0],[10,"head","","Like route, but specialized to the `Head` method.",0],[10,"patch","","Like route, but specialized to the `Patch` method.",0],[10,"options","","Like route, but specialized to the `Options` method.",0],[10,"error","","Add a Handler to be used for this Router's `catch` method.",0],[10,"call","","",0],[10,"catch","","",0],[10,"new","route-recognizer","",1],[10,"insert","","",1],[10,"find","","",1],[10,"clone","route-recognizer::nfa","",2],[10,"clone_from","","",2],[10,"assert_receiver_is_total_eq","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"ne","","",2],[10,"new","","",2],[10,"insert","","",2],[10,"contains","","",2],[10,"clone","","",3],[10,"clone_from","","",3],[10,"assert_receiver_is_total_eq","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"ne","","",3],[10,"any","","",3],[10,"valid","","",3],[10,"invalid","","",3],[10,"valid_char","","",3],[10,"invalid_char","","",3],[10,"matches","","",3],[10,"clone","","",4],[10,"clone_from","","",4],[10,"new","","",4],[10,"start_capture","","",4],[10,"end_capture","","",4],[10,"extract","","",4],[10,"clone","","",5],[10,"clone_from","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"new","","",5],[10,"new","","",6],[10,"clone","","",7],[10,"clone_from","","",7],[10,"new","","",7],[10,"process","","",7],[10,"get","","",7],[10,"get_mut","","",7],[10,"put","","",7],[10,"put_state","","",7],[10,"acceptance","","",7],[10,"start_capture","","",7],[10,"end_capture","","",7],[10,"metadata","","",7],[10,"clone","route-recognizer","",8],[10,"clone_from","","",8],[10,"new","","",8],[10,"cmp","","",8],[10,"partial_cmp","","",8],[10,"lt","","",8],[10,"le","","",8],[10,"gt","","",8],[10,"ge","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"assert_receiver_is_total_eq","","",8],[10,"fmt","","",1],[10,"clone","","",1],[10,"clone_from","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"ne","","",1],[10,"index","","",1],[10,"new","","",9],[10,"clone","","",10],[10,"clone_from","","",10],[10,"new","","",10],[10,"add","","",10],[10,"recognize","","",10],[1,"Params","router",""]],"paths":[[1,"Router"],[1,"Params"],[1,"CharSet"],[2,"CharacterClass"],[1,"Thread"],[1,"State"],[1,"Match"],[1,"NFA"],[1,"Metadata"],[1,"Match"],[1,"Router"]]};

searchIndex['mount'] = {"items":[[0,"","mount","`Mount` provides mounting middleware for the Iron framework."],[1,"Mount","","`Mount` is a simple mounting middleware."],[1,"OriginalUrl","","Exposes the original, unmodified path to be stored in `Request::extensions`."],[10,"new","","Creates a new instance of `Mount`.",0],[10,"mount","","Mounts a given `Handler` onto a route.",0],[10,"call","","",0]],"paths":[[1,"Mount"]]};

searchIndex['bodyparser'] = {"items":[[0,"","bodyparser","Body Parser Plugin for Iron"],[1,"BodyParser","",""],[10,"clone","","",0],[10,"eval","","",0]],"paths":[[1,"BodyParser"]]};

searchIndex['persistent'] = {"items":[[0,"","persistent","A set of middleware for sharing data between requests in the Iron\nframework."],[1,"State","","Middleware for data that persists between requests with read and write capabilities."],[1,"Read","","Middleware for data that persists between Requests with read-only capabilities."],[1,"Write","","Middleware for data that persists between Requests for data which mostly\nneeds to be written instead of read."],[10,"clone","","",0],[10,"clone","","",1],[10,"clone","","",2],[10,"eval","","",1],[10,"eval","","",0],[10,"eval","","",2],[10,"before","","",1],[10,"after","","",1],[10,"before","","",0],[10,"after","","",0],[10,"before","","",2],[10,"after","","",2],[10,"both","","Construct a new pair of `State` that can be passed directly to `Chain::link`.",1],[10,"one","","Construct a new `State` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",1],[10,"both","","Construct a new pair of `Read` that can be passed directly to `Chain::link`.",0],[10,"one","","Construct a new `Read` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",0],[10,"both","","Construct a new pair of `Write` that can be passed directly to `Chain::link`.",2],[10,"one","","Construct a new `Write` that can be passed directly to\n`Chain::link_before` or `Chain::link_after`.",2]],"paths":[[1,"Read"],[1,"State"],[1,"Write"]]};

searchIndex['urlencoded'] = {"items":[[0,"","urlencoded","URL Encoded Plugin for Iron."],[1,"UrlEncodedQuery","","Plugin for `Request` that extracts URL encoded data from the URL query string."],[1,"UrlEncodedBody","","Plugin for `Request` that extracts URL encoded data from the request body."],[4,"QueryMap","","Hashmap mapping strings to vectors of strings."],[10,"eval","","",0],[10,"eval","","",1]],"paths":[[1,"UrlEncodedQuery"],[1,"UrlEncodedBody"]]};

initSearch(searchIndex);
